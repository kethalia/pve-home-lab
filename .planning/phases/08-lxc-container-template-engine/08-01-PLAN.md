---
phase: 08-lxc-container-template-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - templates/engine/lib/logging.sh
  - templates/engine/lib/config.sh
  - templates/engine/lib/state.sh
  - templates/engine/lib/container.sh
  - templates/engine/lib/files.sh
  - templates/engine/lib/hooks.sh
autonomous: true

must_haves:
  truths:
    - "Engine library modules are sourceable from deploy.sh without errors"
    - "yq-based config reader can extract all template.yaml fields"
    - "State file tracks completed scripts and supports resume"
    - "Container helpers wrap pct create/start/stop/destroy with error handling"
    - "File push replaces USER placeholder in paths"
    - "Hook execution runs pre-deploy on host, post-deploy inside container"
  artifacts:
    - path: "templates/engine/lib/logging.sh"
      provides: "Colored logging functions (log_info, log_warn, log_error, log_debug, log_step)"
      min_lines: 30
    - path: "templates/engine/lib/config.sh"
      provides: "yq-based config reader (cfg_get, cfg_get_array, cfg_get_packages)"
      min_lines: 40
    - path: "templates/engine/lib/state.sh"
      provides: "Deploy state management (state_init, state_get, state_set, state_is_done, state_mark_done)"
      min_lines: 40
    - path: "templates/engine/lib/container.sh"
      provides: "pct wrappers (ct_create, ct_start, ct_wait_running, ct_exec, ct_exec_user, ct_stop, ct_destroy, ct_exists)"
      min_lines: 60
    - path: "templates/engine/lib/files.sh"
      provides: "File push with USER replacement (push_template_files)"
      min_lines: 30
    - path: "templates/engine/lib/hooks.sh"
      provides: "Hook runner (run_hook pre_deploy/post_deploy)"
      min_lines: 20
  key_links:
    - from: "templates/engine/lib/config.sh"
      to: "yq binary"
      via: "yq command invocations"
      pattern: "yq.*template\\.yaml"
    - from: "templates/engine/lib/container.sh"
      to: "pct binary"
      via: "pct command invocations"
      pattern: "pct (create|start|stop|exec|push|destroy)"
    - from: "templates/engine/lib/state.sh"
      to: ".deploy-state file"
      via: "grep/sed for key=value"
      pattern: "DEPLOY_STATE"
---

<objective>
Create the reusable engine library modules that power the LXC container template engine.

Purpose: These 6 library files form the core abstraction layer between deploy.sh and the underlying tools (yq, pct, filesystem). Every template deployment uses these functions.
Output: 6 sourceable bash library files in `templates/engine/lib/`
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lxc-container-template-engine/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logging, config, and state library modules</name>
  <files>
    templates/engine/lib/logging.sh
    templates/engine/lib/config.sh
    templates/engine/lib/state.sh
  </files>
  <action>
Create three library files. All must start with `#!/usr/bin/env bash` and be designed to be sourced (not executed directly).

**logging.sh** — Colored terminal output with log levels:

- `LOG_LEVEL` variable (default: "info"), supports: debug, info, warn, error
- `log_debug "msg"` — gray, only when LOG_LEVEL=debug
- `log_info "msg"` — blue prefix `[INFO]`
- `log_warn "msg"` — yellow prefix `[WARN]`
- `log_error "msg"` — red prefix `[ERROR]`
- `log_step "msg"` — bold green prefix `[STEP]`, for major phase transitions
- `log_success "msg"` — green prefix `[OK]`
- Use ANSI color codes with `\033[`. Check if stdout is a terminal before coloring (support piped output).
- All output to stderr (log functions should use `>&2`) so stdout stays clean for machine parsing.

**config.sh** — yq-based YAML config reader:

- Requires `TEMPLATE_DIR` and `TEMPLATE_YAML` to be set before sourcing
- `cfg_get "path"` — reads a single value from template.yaml using yq (e.g., `cfg_get '.container.hostname'`). Returns empty string for null/missing values.
- `cfg_get_default "path" "default"` — reads value with fallback default
- `cfg_get_array "path"` — reads array values, one per line (e.g., `cfg_get_array '.container.features'`)
- `cfg_get_packages "manager"` — reads packages for a specific manager (e.g., `cfg_get_packages 'apt'` reads `.packages.apt[]`)
- `cfg_get_env` — reads `.env` block as KEY=VALUE lines, replacing USER placeholder with the actual username from `.user.name`
- All functions use `yq` (Go version by mikefarah). Handle `null` returns from yq by converting to empty string.

**state.sh** — Deploy state management using `.deploy-state` key=value file:

- `DEPLOY_STATE_FILE` variable (set by deploy.sh, typically `$TEMPLATE_DIR/.deploy-state`)
- `state_init "$ctid"` — creates state file with DEPLOY_STARTED, CTID, PHASE=create, COMPLETED_SCRIPTS=, STATUS=running
- `state_get "key"` — reads value for key from state file
- `state_set "key" "value"` — sets/updates key in state file (uses sed for existing, append for new)
- `state_mark_done "script_name"` — appends script to COMPLETED_SCRIPTS comma-separated list
- `state_is_done "script_name"` — returns 0 if script is in COMPLETED_SCRIPTS list
- `state_set_phase "phase_name"` — convenience for `state_set PHASE phase_name`
- `state_cleanup` — removes the state file (called on successful completion)
  </action>
  <verify>
  Run `bash -n templates/engine/lib/logging.sh && bash -n templates/engine/lib/config.sh && bash -n templates/engine/lib/state.sh` to verify no syntax errors. All three must pass.
  </verify>
  <done>Three library files exist with no bash syntax errors. logging.sh has 6+ log functions, config.sh has 5+ cfg* functions, state.sh has 7+ state* functions.</done>
  </task>

<task type="auto">
  <name>Task 2: Create container, files, and hooks library modules</name>
  <files>
    templates/engine/lib/container.sh
    templates/engine/lib/files.sh
    templates/engine/lib/hooks.sh
  </files>
  <action>
Create three more library files. All must start with `#!/usr/bin/env bash` and be designed to be sourced.

**container.sh** — pct wrapper functions for LXC lifecycle:

- `ct_exists "$ctid"` — returns 0 if container with this CTID exists (checks `pct status`)
- `ct_is_running "$ctid"` — returns 0 if container is running
- `ct_create "$ctid" "$ostemplate" [opts...]` — wraps `pct create` with all options. Accepts an associative-array-style list of options or individual parameters. Must handle: hostname, memory, swap, cores, disk/storage (rootfs), network (net0 with bridge/ip/gw), unprivileged, features, ostype, password, onboot, tags, nameserver, searchdomain. Log the full pct create command at debug level before executing.
- `ct_start "$ctid"` — starts container, waits up to 30s for running state
- `ct_wait_running "$ctid" "$timeout"` — polls `pct status` every 2s until running or timeout
- `ct_exec "$ctid" "$cmd"` — runs command as root inside container via `pct exec $ctid -- bash -c "$cmd"`. Returns the exit code.
- `ct_exec_user "$ctid" "$username" "$cmd"` — runs command as specific user via `pct exec $ctid -- su - $username -c "$cmd"`. This is critical for tools that install to user home dirs (foundry, cargo, etc).
- `ct_push "$ctid" "$local" "$remote" [--perms PERMS] [--user UID] [--group GID]` — wraps `pct push` with optional permissions and ownership
- `ct_stop "$ctid"` — graceful shutdown with 30s timeout, falls back to `pct stop`
- `ct_destroy "$ctid"` — stops if running, then `pct destroy $ctid --purge`
- `ct_install_packages "$ctid" "$packages_string"` — runs `apt-get update && apt-get install -y $packages` inside container. The packages_string is space-separated.
- `ct_next_id` — calls `pvesh get /cluster/nextid` to get next available VMID

All functions should use `log_info`/`log_error`/`log_debug` from logging.sh (assumes it's already sourced).

**files.sh** — Template file push with USER placeholder replacement:

- `push_template_files "$template_dir" "$ctid" "$username"` — iterates over all files in `$template_dir/files/`, replaces `USER` in the path with `$username`, creates parent directories in the container, pushes each file with correct ownership (looks up UID from username — use 1000 as default for non-root users, 0 for root paths).
- `push_single_file "$ctid" "$local_path" "$container_path" "$uid" "$gid"` — pushes one file with ownership
- Files under `/home/$username/` get user ownership (uid:gid of user). Files under `/etc/` or `/usr/` get root ownership (0:0).
- Replace `USER` placeholder in file CONTENTS too (not just paths) using sed before pushing. Create a temp copy, do replacement, push temp copy, delete temp copy.

**hooks.sh** — Hook execution (two modes: host and container):

- `run_hook_host "$template_dir" "$hook_name" "$ctid" "$username"` — runs a hook script ON THE PROXMOX HOST (not inside container). Used for pre_deploy which runs BEFORE the container exists. Looks for `$template_dir/hooks/pre-deploy.sh` (maps underscore to hyphen in filename). Sources and runs the script directly on the host with env vars exported.
- `run_hook_container "$template_dir" "$hook_name" "$ctid" "$username"` — runs a hook script INSIDE THE CONTAINER. Used for post_deploy which runs after container is fully provisioned. Pushes the script to `/tmp/hook-$hook_name.sh`, executes via `ct_exec`, then removes.
- `run_hook "$template_dir" "$hook_name" "$ctid" "$username"` — convenience wrapper that routes: pre_deploy → run_hook_host, post_deploy → run_hook_container.
- All hooks receive environment variables: `CTID`, `HOSTNAME`, `USERNAME`, `TEMPLATE_DIR`
- If hook file doesn't exist, log_debug and skip (not an error).
- If hook fails (non-zero exit), log_error and return 1 (caller decides whether to abort).
- IMPORTANT: pre*deploy runs on the HOST before pct create (validates host prerequisites like OS template, storage, VMID). post_deploy runs INSIDE the container after all scripts/files/packages.
  </action>
  <verify>
  Run `bash -n templates/engine/lib/container.sh && bash -n templates/engine/lib/files.sh && bash -n templates/engine/lib/hooks.sh` to verify no syntax errors.
  </verify>
  <done>Three library files exist with no bash syntax errors. container.sh has 10+ ct* functions, files.sh handles USER replacement in paths and contents, hooks.sh supports host hooks (pre_deploy) and container hooks (post_deploy).</done>
  </task>

</tasks>

<verification>
All 6 library files in `templates/engine/lib/` pass `bash -n` syntax check. Functions follow consistent naming: `log_*`, `cfg_*`, `state_*`, `ct_*`, `push_*`, `run_hook`.
</verification>

<success_criteria>

- 6 bash library files exist in templates/engine/lib/
- All pass bash -n syntax validation
- Functions cover: logging, YAML config reading, state management, pct wrappers, file pushing with USER replacement, hook execution
- No hardcoded template-specific values in engine code
  </success_criteria>

<output>
After completion, create `.planning/phases/08-lxc-container-template-engine/08-01-SUMMARY.md`
</output>
