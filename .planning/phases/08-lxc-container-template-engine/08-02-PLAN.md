---
phase: 08-lxc-container-template-engine
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - templates/engine/deploy.sh
autonomous: true

must_haves:
  truths:
    - "deploy.sh accepts a template name and orchestrates the full deployment pipeline"
    - "CLI flags override template.yaml values (--vmid, --hostname, --cores, --memory, --ip, --gateway)"
    - "--dry-run shows what would happen without executing"
    - "--destroy tears down an existing container"
    - "--resume continues from last completed script"
    - "Pipeline order: validate → pre-deploy hook (on host) → pct create → start → packages → files → scripts → user packages → env → post-deploy hook (in container) → summary"
  artifacts:
    - path: "templates/engine/deploy.sh"
      provides: "Main entry point orchestrating full deployment"
      min_lines: 200
  key_links:
    - from: "templates/engine/deploy.sh"
      to: "templates/engine/lib/*.sh"
      via: "source statements"
      pattern: "source.*lib/(logging|config|state|container|files|hooks)\\.sh"
    - from: "templates/engine/deploy.sh"
      to: "template.yaml"
      via: "cfg_get calls"
      pattern: "cfg_get"
    - from: "templates/engine/deploy.sh"
      to: "pct commands"
      via: "ct_ wrapper functions"
      pattern: "ct_(create|start|exec|push|stop|destroy)"
---

<objective>
Create the main deploy.sh entry point that orchestrates the full LXC container deployment pipeline.

Purpose: This is the single command users run to deploy a template. It parses CLI args, reads template.yaml via the engine libs, and executes the full pipeline: validate → pre-deploy hook → create container → start → install packages → push files → run scripts → post-deploy hook → summary.
Output: `templates/engine/deploy.sh` — executable entry point
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-lxc-container-template-engine/08-RESEARCH.md
@.planning/phases/08-lxc-container-template-engine/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deploy.sh with CLI parsing and validation</name>
  <files>templates/engine/deploy.sh</files>
  <action>
Create `templates/engine/deploy.sh` as the main entry point. Make it executable (`chmod +x`).

**Header and setup:**

```
#!/usr/bin/env bash
set -euo pipefail
```

**Resolve paths:**

- `ENGINE_DIR` = directory containing deploy.sh (use `$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)`)
- `TEMPLATES_ROOT` = parent of ENGINE_DIR (i.e., `templates/`)
- Source all 6 library files from `$ENGINE_DIR/lib/`

**CLI argument parsing** (case statement with while loop):

- First positional arg: template name (e.g., `forge-shield`). Resolve to `$TEMPLATES_ROOT/$template_name/`
- `--vmid N` — override container VMID
- `--hostname NAME` — override hostname
- `--cores N` — override CPU cores
- `--memory N` — override memory (MB)
- `--ip ADDR` — override IP (e.g., `192.168.1.200/24` or `dhcp`)
- `--gateway ADDR` — override gateway
- `--storage NAME` — override storage (default: local-lvm)
- `--dry-run` — print what would be done, don't execute
- `--destroy` — destroy existing container with this VMID
- `--resume` — resume from last completed step
- `--verbose` — set LOG_LEVEL=debug
- `--help` — print usage and exit
- Usage function showing all options with examples

**Validation phase:**

1. Check template name provided and directory exists
2. Check `template.yaml` exists in template directory
3. Check `yq` is installed (if not, offer to install it: download Go binary from mikefarah/yq releases to /usr/local/bin/yq)
4. Check running as root (pct requires root on Proxmox host)
5. Read all config values from template.yaml using `cfg_get`. CLI overrides take precedence over YAML values.
6. Validate VMID is set (from YAML or CLI). If not set, use `ct_next_id` to auto-assign.
7. For `--destroy` action: call `ct_destroy` and exit
8. For `--resume` action: check `.deploy-state` exists, load completed scripts list

**Config resolution order** (CLI > template.yaml > defaults):

- VMID: `--vmid` > `cfg_get '.container.vmid'` > `ct_next_id`
- HOSTNAME: `--hostname` > `cfg_get '.container.hostname'` > template name
- CORES: `--cores` > `cfg_get '.container.cores'` > 2
- MEMORY: `--memory` > `cfg_get '.container.memory'` > 2048
- SWAP: cfg_get '.container.swap' > 512
- DISK: cfg_get '.container.disk' > 8
- STORAGE: `--storage` > `cfg_get '.container.storage'` > "local-lvm"
- OSTEMPLATE: cfg_get '.container.ostemplate' > "local:vztmpl/ubuntu-24.04-standard_24.04-2_amd64.tar.zst"
- IP: `--ip` > `cfg_get '.container.network.ip'` > "dhcp"
- GATEWAY: `--gateway` > `cfg_get '.container.network.gateway'` > ""
- BRIDGE: cfg_get '.container.network.bridge' > "vmbr0"
- UNPRIVILEGED: cfg_get '.container.unprivileged' > true
- FEATURES: join cfg_get_array '.container.features' with comma > "nesting=1"
- USERNAME: cfg_get '.user.name' > "coder"
- USER_SHELL: cfg_get '.user.shell' > "/bin/bash"
- TAGS: join cfg_get_array '.container.tags' with semicolon > ""

After resolving, log all values at debug level.
</action>
<verify>
`bash -n templates/engine/deploy.sh` passes syntax check. `./templates/engine/deploy.sh --help` prints usage (may need to handle missing yq gracefully for help output).
</verify>
<done>deploy.sh parses all CLI flags, validates inputs, and resolves config with CLI > YAML > defaults precedence.</done>
</task>

<task type="auto">
  <name>Task 2: Implement the deployment pipeline in deploy.sh</name>
  <files>templates/engine/deploy.sh</files>
  <action>
Add the main deployment pipeline to deploy.sh after the validation/config section. This is the core orchestration logic.

**Pipeline function `deploy()`** — the main flow:

```
Phase 1: Pre-flight
  - If container already exists and not --force, error and suggest --destroy
  - If --dry-run, print all resolved config and planned actions, then exit 0
  - Initialize state file: state_init "$CTID"

Phase 2: Pre-deploy hook (runs ON HOST, not inside container)
  - state_set_phase "pre_deploy"
  - run_hook "$TEMPLATE_DIR" "pre_deploy" "$CTID" "$USERNAME"
  - This uses run_hook_host internally — the hook script runs on the Proxmox host
  - Validates host prerequisites (OS template exists, storage available, VMID not taken)
  - Container does NOT exist yet at this point

Phase 3: Create container
  - state_set_phase "create"
  - Generate a random root password: ROOT_PASS=$(openssl rand -base64 16)
  - Build pct create command with all resolved config values
  - Network string: "name=eth0,bridge=$BRIDGE,ip=$IP" + add ",gw=$GATEWAY" only if GATEWAY is non-empty
  - Handle DNS: nameserver and searchdomain from cfg_get if set
  - ct_create with all options
  - state_set "ROOT_PASSWORD" "$ROOT_PASS"

Phase 4: Start container
  - state_set_phase "start"
  - ct_start "$CTID"
  - ct_wait_running "$CTID" 30
  - Sleep 3 seconds for container networking to stabilize

Phase 5: Install packages
  - state_set_phase "packages"
  - Read apt packages: cfg_get_packages "apt" → space-joined string
  - If apt packages exist: ct_exec to run apt-get update && apt-get install -y $packages
  - Set up locale: ct_exec "locale-gen en_US.UTF-8 && update-locale LANG=en_US.UTF-8"

Phase 6: Push files
  - state_set_phase "files"
  - push_template_files "$TEMPLATE_DIR" "$CTID" "$USERNAME"

Phase 7: Run scripts
  - state_set_phase "scripts"
  - Find all scripts in $TEMPLATE_DIR/scripts/ matching [0-9][0-9]_*.sh, sorted by name
  - For each script:
    - If --resume and state_is_done "$script_name": log_info "Skipping (already done): $script_name" and continue
    - log_step "Running script: $script_name"
    - Set up environment variables for the script (USERNAME, USER_SHELL, CTID, plus all from cfg_get_env)
    - Create a wrapper script that exports env vars then sources the actual script
    - Push the actual script to /tmp/ in container
    - Push the wrapper to /tmp/ in container
    - ct_exec to run the wrapper as root (scripts that need user context should use `su - $USERNAME` internally)
    - If script fails: log_error, state_set "FAILED_SCRIPT" "$script_name", state_set "STATUS" "failed", exit 1
    - If script succeeds: state_mark_done "$script_name"
    - Clean up /tmp/ scripts in container

Phase 8: Install user-level packages (pip, npm, cargo, go — run as user)
  - After scripts complete, handle non-apt package managers:
  - pip packages (from cfg_get_packages "pip"): ct_exec_user to run `pipx install $pkg` for each
  - npm packages (from cfg_get_packages "npm"): ct_exec_user to run `npm install -g $pkg` for each
  - cargo packages (from cfg_get_packages "cargo"): ct_exec_user to run `cargo install $pkg` for each
  - go packages (from cfg_get_packages "go"): ct_exec_user to run `go install $pkg` for each
  - NOTE: These run after scripts because scripts install the package managers (node, python, go, rust)

Phase 9: Set environment
  - Configure PATH additions from cfg_get_array '.env.PATH_APPEND' — append to /home/$USERNAME/.profile
  - Set env vars from `.env` block (excluding PATH_APPEND) — write to /home/$USERNAME/.profile
  - Ensure .profile is sourced from .bashrc/.zshrc

Phase 10: Post-deploy hook (runs INSIDE container)
  - state_set_phase "post_deploy"
  - run_hook "$TEMPLATE_DIR" "post_deploy" "$CTID" "$USERNAME"
  - This uses run_hook_container internally — pushes hook into container and executes it

Phase 11: Summary
  - state_set "STATUS" "complete"
  - state_set "DEPLOY_COMPLETED" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  - Print deployment summary to stdout:
    - Template name, version, description
    - Container ID, hostname, IP
    - Root password (from state file)
    - Username
    - "Container is ready! Connect with: pct enter $CTID"
    - Time elapsed (compute from DEPLOY_STARTED)
  - state_cleanup (remove .deploy-state on success)
```

At the bottom of deploy.sh, call `deploy` after all setup is done.

**Error handling:**

- Trap ERR to log errors with context (which phase, which script)
- On fatal error, DON'T destroy the container — leave it for debugging
- State file persists on failure so --resume works
  </action>
  <verify>
  `bash -n templates/engine/deploy.sh` passes syntax check. `./templates/engine/deploy.sh --dry-run forge-shield` (or `./templates/engine/deploy.sh forge-shield --dry-run` if template exists) shows resolved config without executing.
  </verify>
  <done>deploy.sh implements the full 11-phase pipeline: pre-flight → pre-deploy hook → create → start → apt packages → files → scripts → user packages → env → post-deploy hook → summary. Supports --dry-run, --destroy, --resume, and CLI overrides.</done>
  </task>

</tasks>

<verification>
- `bash -n templates/engine/deploy.sh` passes
- deploy.sh sources all 6 lib files
- deploy.sh --help shows usage with all flags
- deploy.sh --dry-run with a valid template shows resolved config
- Pipeline phases are in correct order
</verification>

<success_criteria>

- deploy.sh is executable and passes syntax validation
- Full deployment pipeline from create to summary is implemented
- CLI argument parsing handles all specified flags
- Config resolution follows CLI > YAML > defaults precedence
- --dry-run, --destroy, --resume all work
- Error handling preserves state file for resume capability
  </success_criteria>

<output>
After completion, create `.planning/phases/08-lxc-container-template-engine/08-02-SUMMARY.md`
</output>
