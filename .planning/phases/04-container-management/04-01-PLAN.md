---
phase: 04-container-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/src/lib/containers/actions.ts
  - apps/dashboard/src/lib/containers/helpers.ts
  - apps/dashboard/src/lib/db.ts
autonomous: true

must_haves:
  truths:
    - "Server actions can start, stop, shutdown, restart, and delete containers"
    - "Each lifecycle action validates current state, calls Proxmox API, waits for completion, updates DB, and creates a ContainerEvent"
    - "Delete action stops running containers before deletion and removes the container from both Proxmox and the database"
    - "Shutdown action falls back to force stop if graceful shutdown times out"
    - "DatabaseService provides query methods for listing containers with relations and getting aggregate counts"
    - "A reusable helper creates a ProxmoxClient from the current session"
  artifacts:
    - path: "apps/dashboard/src/lib/containers/helpers.ts"
      provides: "createProxmoxClientFromSession helper, getContainerNode helper"
      contains: "createProxmoxClientFromSession"
    - path: "apps/dashboard/src/lib/containers/actions.ts"
      provides: "Server actions for start, stop, shutdown, restart, delete with state validation and event logging"
      contains: "use server"
    - path: "apps/dashboard/src/lib/db.ts"
      provides: "listContainersWithRelations, getContainerCounts, getContainerWithDetails, deleteContainerById, updateContainerServices methods"
      contains: "listContainersWithRelations"
  key_links:
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/containers/helpers.ts"
      via: "Actions use createProxmoxClientFromSession to get authenticated client"
      pattern: "createProxmoxClientFromSession"
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/proxmox/containers.ts"
      via: "Actions call startContainer, stopContainer, shutdownContainer, deleteContainer"
      pattern: "startContainer|stopContainer|shutdownContainer|deleteContainer"
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Actions create ContainerEvent records and update lifecycle"
      pattern: "DatabaseService\\.createContainerEvent|DatabaseService\\.updateContainerLifecycle"
    - from: "apps/dashboard/src/lib/containers/helpers.ts"
      to: "apps/dashboard/src/lib/session.ts"
      via: "Gets Proxmox credentials from session"
      pattern: "getProxmoxCredentials"
---

<objective>
Create container lifecycle server actions (start/stop/shutdown/restart/delete) and shared infrastructure: a ProxmoxClient-from-session helper and additional DatabaseService query methods needed by the dashboard and detail pages.

Purpose: These server actions are the backend for all container control UI (quick actions on dashboard, action buttons on detail page). The DB query methods and client helper are shared infrastructure needed by both UI plans in Wave 2.

Output: Server actions file, client helper, and extended DatabaseService — ready for Wave 2 UI consumption.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

@apps/dashboard/src/lib/db.ts
@apps/dashboard/src/lib/session.ts
@apps/dashboard/src/lib/proxmox/client.ts
@apps/dashboard/src/lib/proxmox/containers.ts
@apps/dashboard/src/lib/proxmox/tasks.ts
@apps/dashboard/src/lib/proxmox/types.ts
@apps/dashboard/src/lib/auth/actions.ts
@apps/dashboard/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: ProxmoxClient-from-session helper and DatabaseService query methods</name>
  <files>
    apps/dashboard/src/lib/containers/helpers.ts
    apps/dashboard/src/lib/db.ts
  </files>
  <action>
**Part A: Create `src/lib/containers/helpers.ts`**

This provides a reusable pattern for getting an authenticated ProxmoxClient from the current session. Every server action and data-fetching function needs this. Mark with `import "server-only"` since these helpers are only used in Next.js server context (not the worker).

```ts
import "server-only";

import { ProxmoxClient } from "@/lib/proxmox/client";
import { getProxmoxCredentials } from "@/lib/session";
import { DatabaseService } from "@/lib/db";

/**
 * Create an authenticated ProxmoxClient from the current user session.
 * Looks up the first ProxmoxNode in DB for host/port config.
 * Throws if session is invalid or no node is configured.
 */
export async function createProxmoxClientFromSession(): Promise<{
  client: ProxmoxClient;
  node: { id: string; name: string; host: string; port: number };
}> {
  const credentials = await getProxmoxCredentials();
  if (!credentials) {
    throw new Error("Not authenticated");
  }

  // Get the first configured node (single-node setup)
  const nodes = await DatabaseService.listNodes();
  const pveNode = nodes[0];
  if (!pveNode) {
    throw new Error("No Proxmox node configured");
  }

  const client = new ProxmoxClient({
    host: pveNode.host,
    port: pveNode.port,
    credentials,
    verifySsl: false,
  });

  return {
    client,
    node: {
      id: pveNode.id,
      name: pveNode.name,
      host: pveNode.host,
      port: pveNode.port,
    },
  };
}
```

Export: `createProxmoxClientFromSession`.

**Part B: Add query methods to DatabaseService in `src/lib/db.ts`**

Add these methods to the DatabaseService class after the existing ContainerService methods (from Phase 3):

1. **`listContainersWithRelations()`** — Returns all containers with their node, template, services, and latest 3 events. Used by dashboard page.

```ts
static async listContainersWithRelations() {
  return this.prisma.container.findMany({
    include: {
      node: true,
      template: { select: { id: true, name: true } },
      services: true,
      events: {
        orderBy: { createdAt: "desc" },
        take: 3,
      },
    },
    orderBy: { createdAt: "desc" },
  });
}
```

2. **`getContainerCounts()`** — Returns count of containers by lifecycle status. Used by dashboard summary bar.

```ts
static async getContainerCounts() {
  const [total, creating, ready, error] = await Promise.all([
    this.prisma.container.count(),
    this.prisma.container.count({ where: { lifecycle: "creating" } }),
    this.prisma.container.count({ where: { lifecycle: "ready" } }),
    this.prisma.container.count({ where: { lifecycle: "error" } }),
  ]);
  return { total, creating, ready, error };
}
```

3. **`getContainerWithDetails(id: string)`** — Returns a single container with ALL relations (full events list, all services, node, template). Used by detail page.

```ts
static async getContainerWithDetails(id: string) {
  return this.prisma.container.findUnique({
    where: { id },
    include: {
      node: true,
      template: true,
      services: true,
      events: {
        orderBy: { createdAt: "desc" },
      },
    },
  });
}
```

4. **`deleteContainerById(id: string)`** — Deletes a container and all related records (cascade handles services/events). Used by delete action.

```ts
static async deleteContainerById(id: string): Promise<void> {
  await this.prisma.container.delete({ where: { id } });
}
```

5. **`updateContainerServices(containerId: string, services: Array<{ id: string; status: ServiceStatus; port?: number; webUrl?: string; credentials?: string }>)`** — Bulk-updates service records. Used by service monitoring engine.

```ts
static async updateContainerServices(
  containerId: string,
  updates: Array<{
    id: string;
    status: ServiceStatus;
    port?: number;
    webUrl?: string;
    credentials?: string;
  }>,
): Promise<void> {
  await this.prisma.$transaction(
    updates.map((u) =>
      this.prisma.containerService.update({
        where: { id: u.id },
        data: {
          status: u.status,
          ...(u.port !== undefined && { port: u.port }),
          ...(u.webUrl !== undefined && { webUrl: u.webUrl }),
          ...(u.credentials !== undefined && { credentials: u.credentials }),
        },
      }),
    ),
  );
}
```

Note: If Phase 3 already added `getContainerById` with includes, `getContainerWithDetails` is a more comprehensive version. Keep both — `getContainerById` is used by the worker (simpler), `getContainerWithDetails` is for the detail page (full).

  </action>
  <verify>
    - `npx tsc --noEmit` passes in apps/dashboard
    - `apps/dashboard/src/lib/containers/helpers.ts` exists and exports `createProxmoxClientFromSession`
    - DatabaseService has methods: listContainersWithRelations, getContainerCounts, getContainerWithDetails, deleteContainerById, updateContainerServices
  </verify>
  <done>
    - createProxmoxClientFromSession helper encapsulates session → client pattern
    - DatabaseService has all query methods needed by dashboard (list+counts), detail page (full details), delete action, and service monitoring (bulk update)
    - All methods type-safe with Prisma includes
  </done>
</task>

<task type="auto">
  <name>Task 2: Container lifecycle server actions</name>
  <files>
    apps/dashboard/src/lib/containers/actions.ts
  </files>
  <action>
Create `src/lib/containers/actions.ts` (or extend if Phase 3 already created it with `createContainerAction`). Add `"use server"` directive at top.

**Important:** Phase 3's plan 03-03 creates this file with `createContainerAction`. If the file already exists, ADD the new actions below the existing createContainerAction. If it doesn't exist yet (Phase 3 not executed), create it fresh with just these lifecycle actions.

Define a shared `ActionResult` type:

```ts
export interface ActionResult {
  success: boolean;
  error?: string;
}
```

**Create these server actions:**

1. **`startContainerAction(containerId: string): Promise<ActionResult>`**
   - Call `createProxmoxClientFromSession()` to get client + node
   - Call `DatabaseService.getContainerById(containerId)` — return error if not found
   - Call `getContainer(client, node.name, container.vmid)` to check Proxmox status — return error if already running
   - Call `startContainer(client, node.name, container.vmid)` to get UPID
   - Call `waitForTask(client, node.name, upid, { timeout: 30000 })` — 30s timeout
   - Call `DatabaseService.createContainerEvent({ containerId, type: "started", message: "Container started" })`
   - Return `{ success: true }`
   - On error: return `{ success: false, error: "Failed to start container" }` (generic message, no Proxmox detail leakage)

2. **`stopContainerAction(containerId: string): Promise<ActionResult>`**
   - Same pattern: get client, get container, check status (error if already stopped)
   - Call `stopContainer(client, node.name, container.vmid)` — force stop
   - Wait for task (30s timeout)
   - Create "stopped" event
   - Return `{ success: true }`

3. **`shutdownContainerAction(containerId: string): Promise<ActionResult>`**
   - Same pattern: get client, get container, check status (error if not running)
   - Call `shutdownContainer(client, node.name, container.vmid, 60)` — 60s graceful timeout
   - Try `waitForTask(client, node.name, upid, { timeout: 90000 })` — 90s wait
   - If task fails/times out, fall back to `stopContainer()` + `waitForTask()` — force stop
   - Create "stopped" event with message indicating graceful or forced
   - Return `{ success: true }`

4. **`restartContainerAction(containerId: string): Promise<ActionResult>`**
   - Get client, get container, check status
   - If running: shutdown (graceful 30s) → wait → start → wait
   - If stopped: just start → wait
   - Create "stopped" then "started" events (or just "started" if was stopped)
   - Return `{ success: true }`

5. **`deleteContainerAction(containerId: string): Promise<ActionResult>`**
   - Get client, get container (error if not found)
   - Check Proxmox status: if running, stop first (stopContainer + waitForTask)
   - Call `deleteContainer(client, node.name, container.vmid, true)` — purge=true
   - Wait for delete task (60s timeout)
   - Call `DatabaseService.deleteContainerById(containerId)` to remove from DB
   - Return `{ success: true }`
   - On error: return `{ success: false, error: "Failed to delete container" }`

**Patterns to follow:**

- Use `try/catch` around all Proxmox API calls
- Don't leak Proxmox error details to client (per project decision in STATE.md)
- Import from `@/lib/proxmox/containers` for API functions
- Import from `@/lib/proxmox/tasks` for waitForTask
- Import from `@/lib/containers/helpers` for createProxmoxClientFromSession
- Import from `@/lib/db` for DatabaseService

**Revalidation:** After each successful action, call `revalidatePath("/")` and `revalidatePath("/containers/[id]")` (use the actual format `revalidatePath("/containers/" + containerId)`) to trigger Next.js cache refresh. Import from `next/cache`.

  </action>
  <verify>
    - `npx tsc --noEmit` passes in apps/dashboard
    - File has `"use server"` directive
    - All 5 actions exported: startContainerAction, stopContainerAction, shutdownContainerAction, restartContainerAction, deleteContainerAction
    - Each action creates ContainerEvent records
    - Each action calls revalidatePath
    - shutdownContainerAction has stop fallback logic
    - deleteContainerAction stops running containers before deletion
  </verify>
  <done>
    - 5 lifecycle server actions: start, stop, shutdown (with fallback), restart, delete
    - Each action validates state, calls Proxmox API, waits for completion, creates events
    - Delete handles running containers (stops first) and removes from both Proxmox and DB
    - All actions revalidate dashboard and detail page paths
    - Generic error messages (no Proxmox detail leakage)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all files type-check
2. `createProxmoxClientFromSession` helper creates client from session credentials + DB node config
3. DatabaseService has: listContainersWithRelations, getContainerCounts, getContainerWithDetails, deleteContainerById, updateContainerServices
4. 5 lifecycle server actions exist with proper state validation and event logging
5. Shutdown has graceful→force fallback
6. Delete stops running containers before deletion
7. All actions call revalidatePath for cache refresh
</verification>

<success_criteria>

- Helper provides reusable ProxmoxClient creation from session (no more copy-paste pattern)
- DatabaseService extended with all query methods Wave 2 UI needs
- 5 lifecycle actions work: start/stop/shutdown/restart/delete with proper error handling
- Each action creates ContainerEvent for audit trail
- Delete removes from both Proxmox and DB
- Shutdown gracefully falls back to force stop
  </success_criteria>

<output>
After completion, create `.planning/phases/04-container-management/04-01-SUMMARY.md`
</output>
