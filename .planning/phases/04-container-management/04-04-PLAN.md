---
phase: 04-container-management
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02", "04-03"]
files_modified:
  - apps/dashboard/src/app/(dashboard)/containers/[id]/page.tsx
  - apps/dashboard/src/app/(dashboard)/containers/[id]/container-detail.tsx
  - apps/dashboard/src/components/containers/detail/overview-tab.tsx
  - apps/dashboard/src/components/containers/detail/services-tab.tsx
  - apps/dashboard/src/components/containers/detail/events-tab.tsx
  - apps/dashboard/src/components/containers/detail/container-header.tsx
  - apps/dashboard/src/lib/containers/actions.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate to /containers/[id] and see container details with tabs"
    - "Overview tab shows resources, network config, features, template info, node, and dates"
    - "Services tab shows service status badges, web UI buttons, credentials (hidden by default), and a refresh button"
    - "Events tab shows a chronological event log with type icons and timestamps"
    - "Lifecycle action buttons (start/stop/shutdown/restart/delete) appear in the page header"
    - "If container is in 'creating' lifecycle, the page redirects to the progress view"
    - "Service refresh button triggers SSH-based monitoring and updates service records"
  artifacts:
    - path: "apps/dashboard/src/app/(dashboard)/containers/[id]/page.tsx"
      provides: "Server component that fetches container details and Proxmox config"
      contains: "getContainerDetailData"
    - path: "apps/dashboard/src/app/(dashboard)/containers/[id]/container-detail.tsx"
      provides: "Client component with tab navigation (Overview, Services, Events)"
      contains: "use client"
    - path: "apps/dashboard/src/components/containers/detail/services-tab.tsx"
      provides: "Services tab with status badges, web UI links, credential reveal, and refresh button"
      contains: "refreshContainerServicesAction"
    - path: "apps/dashboard/src/lib/containers/actions.ts"
      provides: "refreshContainerServicesAction server action (appended to existing lifecycle actions)"
      contains: "refreshContainerServicesAction"
  key_links:
    - from: "apps/dashboard/src/app/(dashboard)/containers/[id]/page.tsx"
      to: "apps/dashboard/src/lib/containers/data.ts"
      via: "Server component calls getContainerDetailData for combined DB + Proxmox data"
      pattern: "getContainerDetailData"
    - from: "apps/dashboard/src/components/containers/detail/container-header.tsx"
      to: "apps/dashboard/src/lib/containers/actions.ts"
      via: "Header action buttons call lifecycle server actions"
      pattern: "startContainerAction|stopContainerAction|shutdownContainerAction|restartContainerAction|deleteContainerAction"
    - from: "apps/dashboard/src/components/containers/detail/services-tab.tsx"
      to: "apps/dashboard/src/lib/containers/actions.ts"
      via: "Refresh button calls refreshContainerServicesAction"
      pattern: "refreshContainerServicesAction"
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/containers/monitoring.ts"
      via: "refreshContainerServicesAction calls monitorContainer"
      pattern: "monitorContainer"
---

<objective>
Build the container detail page at /containers/[id] with three tabs: Overview (resources, network, features), Services (status, web UI links, credentials), and Events (chronological log). Includes lifecycle action buttons in the header, a service refresh action wired to the monitoring engine, and smart routing for creating containers.

Purpose: This is the deep-dive view for a single container. Users inspect configuration, monitor service health, view event history, and control the container lifecycle from here.

Output: Complete container detail page with tabbed interface, full lifecycle controls, and service monitoring integration.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-container-management/04-01-SUMMARY.md
@.planning/phases/04-container-management/04-02-SUMMARY.md
@.planning/phases/04-container-management/04-03-SUMMARY.md

@apps/dashboard/src/lib/db.ts
@apps/dashboard/src/lib/containers/helpers.ts
@apps/dashboard/src/lib/containers/actions.ts
@apps/dashboard/src/lib/containers/data.ts
@apps/dashboard/src/lib/containers/monitoring.ts
@apps/dashboard/src/lib/proxmox/containers.ts
@apps/dashboard/src/lib/proxmox/schemas.ts
@apps/dashboard/src/components/containers/status-badge.tsx
@apps/dashboard/src/components/containers/container-actions.tsx
@apps/dashboard/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: refreshContainerServicesAction + detail page server component</name>
  <files>
    apps/dashboard/src/lib/containers/actions.ts
    apps/dashboard/src/app/(dashboard)/containers/[id]/page.tsx
  </files>
  <action>
**Part A: Add `refreshContainerServicesAction` to existing `src/lib/containers/actions.ts`**

Append to the existing file (which already has lifecycle actions from Plan 04-01). Add these imports if not already present:

- `getContainer`, `getContainerConfig` from `@/lib/proxmox/containers`

Add a non-exported helper:

```ts
function extractIpFromNet0(net0: string): string | null {
  // net0 format: "name=eth0,bridge=vmbr0,ip=10.0.0.50/24,gw=10.0.0.1"
  const ipMatch = net0.match(/ip=(\d+\.\d+\.\d+\.\d+)/);
  return ipMatch ? ipMatch[1] : null;
}
```

Add the server action:

```ts
export async function refreshContainerServicesAction(
  containerId: string,
): Promise<ActionResult> {
  try {
    const { client, node } = await createProxmoxClientFromSession();
    const container =
      await DatabaseService.getContainerWithDetails(containerId);

    if (!container) {
      return { success: false, error: "Container not found" };
    }

    if (container.lifecycle !== "ready") {
      return { success: false, error: "Container is not ready" };
    }

    // Check Proxmox status — must be running for SSH
    const pveStatus = await getContainer(client, node.name, container.vmid);
    if (pveStatus.status !== "running") {
      return { success: false, error: "Container is not running" };
    }

    // Extract IP from Proxmox config
    const config = await getContainerConfig(client, node.name, container.vmid);
    const ip = extractIpFromNet0(config.net0 || "");
    if (!ip) {
      return { success: false, error: "Cannot determine container IP address" };
    }

    // Decrypt root password
    const { decrypt } = await import("@/lib/encryption");
    const rootPassword = decrypt(container.rootPassword);

    // Run monitoring (dynamic import to avoid pulling SSH into server action bundle)
    const { monitorContainer } = await import("@/lib/containers/monitoring");
    const serviceNames = container.services.map((s) => s.name);
    const result = await monitorContainer(
      containerId,
      ip,
      rootPassword,
      serviceNames,
    );

    if (result.error) {
      return { success: false, error: "Cannot connect to container via SSH" };
    }

    // Update service records based on monitoring results
    const serviceUpdates = container.services.map((svc) => {
      const check = result.services.find((s) => s.name === svc.name);
      const portInfo = result.ports.find((p) => p.port === svc.port);
      const creds = result.credentials.filter((c) => c.service === svc.name);

      let status: "running" | "stopped" | "error" = "stopped";
      if (check?.active) status = "running";
      else if (portInfo) status = "running";

      return {
        id: svc.id,
        status,
        ...(portInfo && { port: portInfo.port }),
        ...(creds.length > 0 && {
          credentials: JSON.stringify(
            Object.fromEntries(creds.map((c) => [c.key, c.value])),
          ),
        }),
      };
    });

    if (serviceUpdates.length > 0) {
      await DatabaseService.updateContainerServices(
        containerId,
        serviceUpdates,
      );
    }

    revalidatePath(`/containers/${containerId}`);
    return { success: true };
  } catch {
    return { success: false, error: "Failed to refresh services" };
  }
}
```

**Part B: Create `src/app/(dashboard)/containers/[id]/page.tsx`** (server component)

```tsx
import { notFound, redirect } from "next/navigation";
import { getContainerDetailData } from "@/lib/containers/data";
import { ContainerDetail } from "./container-detail";

interface Props {
  params: Promise<{ id: string }>;
}

export default async function ContainerDetailPage({ params }: Props) {
  const { id } = await params;
  const data = await getContainerDetailData(id);

  if (!data) {
    notFound();
  }

  // If container is being created, redirect to progress page (Phase 3)
  if (data.lifecycle === "creating") {
    redirect(`/containers/${id}/progress`);
  }

  return <ContainerDetail {...data} />;
}
```

Note: In Next.js 15, `params` is a Promise that must be awaited. Use `notFound()` for missing containers and redirect creating containers to progress view.

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `refreshContainerServicesAction` is exported from actions.ts
    - Action calls monitorContainer from monitoring.ts via dynamic import
    - Action updates ContainerService records via DatabaseService.updateContainerServices
    - `/containers/[id]/page.tsx` exists and calls getContainerDetailData
    - Creating containers redirect to progress page
    - Missing containers return 404
  </verify>
  <done>
    - refreshContainerServicesAction wires monitoring engine to DB via session-authenticated flow
    - Detail page server component fetches merged DB + Proxmox data
    - Smart routing: creating → progress, not found → 404
    - IP extraction from Proxmox net0 config
  </done>
</task>

<task type="auto">
  <name>Task 2: Container header and detail shell</name>
  <files>
    apps/dashboard/src/components/containers/detail/container-header.tsx
    apps/dashboard/src/app/(dashboard)/containers/[id]/container-detail.tsx
  </files>
  <action>
**1. Create `src/components/containers/detail/container-header.tsx`** (client component — `"use client"`)

Header with container name, VMID, status badge, and action buttons.

Props: `{ id: string; hostname: string | null; vmid: number; status: ContainerStatus; lifecycle: string }`

Layout:

- Top: Back link "← Back to Dashboard" using Next.js Link to "/"
- Left: Hostname (h1, text-2xl font-bold) + "VMID {vmid}" (muted small text) + StatusBadge (reuse from 04-03)
- Right: Action buttons based on status:
  - Running: "Shutdown" (primary), "Stop" (outline), "Restart" (outline), "Delete" (destructive)
  - Stopped: "Start" (primary), "Delete" (destructive)
  - Creating/Error/Unknown: "Delete" (destructive) only

Each button uses `useTransition` for pending state (show spinner while pending, disable all buttons).
Import and call lifecycle server actions from `@/lib/containers/actions`.
After delete succeeds, redirect to "/" using `useRouter().push("/")`.
Use `confirm()` for destructive actions (stop, delete).

**2. Create `src/app/(dashboard)/containers/[id]/container-detail.tsx`** (client component — `"use client"`)

Tab container with navigation.

Props: full `ContainerDetailData` (spread all fields)

Layout:

- `<ContainerHeader>` at top with id, hostname, vmid, status, lifecycle
- Tab navigation bar: three buttons — "Overview", "Services ({services.length})", "Events ({events.length})"
  - Active tab: `border-b-2 border-primary font-semibold text-foreground`
  - Inactive: `text-muted-foreground hover:text-foreground`
  - Use `useState<"overview" | "services" | "events">("overview")` for tab state
- Tab content: conditionally render the active tab component
  - "overview": `<OverviewTab config={config} resources={resources} template={template} node={node} createdAt={createdAt} />`
  - "services": `<ServicesTab services={services} containerId={id} status={status} />`
  - "events": `<EventsTab events={events} />`

    </action>
    <verify>
      - `npx tsc --noEmit` passes
      - ContainerHeader has lifecycle action buttons with useTransition
      - container-detail.tsx has tab navigation with 3 tabs
      - Delete redirects to "/" after success
      - All components use shadcn/ui and Tailwind classes
    </verify>
    <done>
      - Container header with status badge and lifecycle action buttons (optimistic UI)
      - Container detail shell with tabbed navigation (Overview, Services, Events)
    </done>
  </task>

<task type="auto">
  <name>Task 3: Overview tab</name>
  <files>
    apps/dashboard/src/components/containers/detail/overview-tab.tsx
  </files>
  <action>
Create `src/components/containers/detail/overview-tab.tsx` (server component — no client interactivity needed).

Shows container configuration and live resource usage.

Props: `{ config: ContainerDetailData["config"]; resources: ContainerDetailData["resources"]; template: ContainerDetailData["template"]; node: ContainerDetailData["node"]; createdAt: Date }`

Layout — two columns on desktop (`grid grid-cols-1 lg:grid-cols-2 gap-6`), stacked on mobile:

**Left — Configuration Card:**

- Card title: "Configuration"
- Grid of key-value pairs (use `dl` with `dt`/`dd` or simple label:value rows):
  - Hostname, OS Type, Architecture
  - Cores, Memory (format MB), Swap (format MB), Disk (rootfs string)
  - Network (parse net0: show bridge and IP)
  - DNS: nameserver, searchdomain
  - Features: parse "nesting=1,keyctl=1" into individual badges (green for enabled)
  - Unprivileged: Yes/No
  - Boot on start: Yes/No
  - Tags: comma-split into badges

**Right — Resource Usage Card (only if container is running):**

- Card title: "Resource Usage"
- CPU: percentage with colored progress bar (green <60%, yellow 60-80%, red >80%)
- Memory: used/max with progress bar, format as "256 MB / 512 MB"
- Swap: used/max with progress bar
- Disk: used/max with progress bar
- Uptime: format seconds as "Xd Xh Xm"
- Network I/O: netIn/netOut formatted as KB/MB/GB

If resources are null (API failed or container stopped), show "Container is stopped" or "Data unavailable" message.

**Right — Details Card (below resources):**

- Template: name (or "Custom" if null)
- Node: node name
- Created: formatted date (e.g., "Feb 6, 2026")

Helper functions (define in the file or a shared utils):

- `formatBytes(bytes: number): string` — "1.5 GB", "256 MB", "32 KB"
- `formatUptime(seconds: number): string` — "2d 5h 30m"

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - OverviewTab shows config card with all key-value pairs
    - Resource usage card shows progress bars with color coding
    - formatBytes and formatUptime helpers work correctly
    - Handles null resources gracefully (stopped container)
  </verify>
  <done>
    - Overview tab with configuration grid and live resource usage
    - Progress bars with color coding for CPU/Memory/Swap/Disk
    - Uptime and network I/O formatted readably
    - Graceful handling of stopped containers (no resources)
  </done>
</task>

<task type="auto">
  <name>Task 4: Services tab and events tab</name>
  <files>
    apps/dashboard/src/components/containers/detail/services-tab.tsx
    apps/dashboard/src/components/containers/detail/events-tab.tsx
  </files>
  <action>
**1. Create `src/components/containers/detail/services-tab.tsx`** (client component — `"use client"`)

Shows container services with status and controls.

Props: `{ services: ContainerDetailData["services"]; containerId: string; status: ContainerStatus }`

Layout:

- Header row: "Services" title + "Refresh Status" button
  - Refresh button calls `refreshContainerServicesAction(containerId)` with `useTransition`
  - Shows spinner while pending
  - Disabled when container status !== "running"

- If no services: show "No services configured for this container" message in a muted Card

- Service list (each service as a Card):
  - **Header:** Service name (bold) + Type badge (e.g., "systemd" in gray pill)
  - **Status:** StatusBadge-style indicator (running=green, stopped=gray, installing=blue, error=red)
  - **Port:** If set, show "Port: {port}"
  - **Web URL:** If set, show "Open Web UI →" as a Button variant="link" that opens in new tab (`target="_blank"`)
  - **Credentials:** If set, show "Show Credentials" toggle button. Default: hidden.
    - On click, toggle `useState` to show parsed JSON as a key-value grid
    - Parse `JSON.parse(credentials)` into `{key: value}` pairs
    - Display in a grid with monospace font, each value in a `<code>` block
    - **Security note:** Only reveal on explicit click, not on page load

**2. Create `src/components/containers/detail/events-tab.tsx`** (client component — `"use client"` for filter state)

Chronological event log.

Props: `{ events: ContainerDetailData["events"] }`

Layout:

- Filter buttons: "All", "Created", "Started", "Stopped", "Error", "Service", "Script" — use `useState` for active filter
- Event list (most recent first, already sorted from query):
  Each event row:
  - Left: Type icon (color-coded circle or Lucide icon):
    - created → blue Circle
    - started → green Play
    - stopped → gray Square
    - error → red AlertCircle
    - service_ready → green CheckCircle
    - script_completed → blue Terminal
  - Center: Message text + metadata toggle (if metadata exists, show "Details" expand button → `<pre>` with JSON)
  - Right: Relative timestamp (e.g., "5 min ago") with absolute time on hover (`title` attribute)

If no events: "No events recorded"

Reuse `timeAgo()` helper from container-card.tsx (or define locally).

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - ServicesTab has refresh button calling refreshContainerServicesAction
    - ServicesTab has credential reveal toggle (hidden by default)
    - EventsTab shows timeline with type icons and filters
    - All components use shadcn/ui Card and Tailwind classes
  </verify>
  <done>
    - Services tab: status badges, web UI links, credential reveal, refresh via monitoring
    - Events tab: chronological timeline with icons and type filters
    - Both tabs handle empty state gracefully
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all files type-check
2. Detail page server component fetches merged data via getContainerDetailData
3. Three tabs render correct content (Overview, Services, Events)
4. Lifecycle actions in header work (start/stop/shutdown/restart/delete)
5. Services refresh button triggers monitoring engine via refreshContainerServicesAction
6. Credentials are hidden by default, revealed on click
7. Events timeline shows all event types with appropriate icons
8. Creating containers redirect to progress page
9. Missing containers return 404
10. refreshContainerServicesAction correctly wires monitoring → DB updates
</verification>

<success_criteria>

- Container detail page shows comprehensive info across 3 tabs
- Live Proxmox data shown in Overview (resources, config)
- Service monitoring refresh works from Services tab
- Event history visible with filtering
- Lifecycle controls accessible from header
- Creating containers correctly redirected
- Graceful degradation when Proxmox API unavailable
- Service credentials safely hidden by default
  </success_criteria>

<output>
After completion, create `.planning/phases/04-container-management/04-04-SUMMARY.md`
</output>
