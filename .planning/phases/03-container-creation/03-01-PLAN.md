---
phase: 03-container-creation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/src/lib/db.ts
  - apps/dashboard/src/lib/proxmox/client.ts
  - apps/dashboard/src/lib/proxmox/containers.ts
  - apps/dashboard/src/lib/proxmox/tasks.ts
  - apps/dashboard/src/lib/proxmox/auth.ts
  - apps/dashboard/src/lib/proxmox/nodes.ts
  - apps/dashboard/src/lib/proxmox/storage.ts
  - apps/dashboard/src/lib/proxmox/templates.ts
  - apps/dashboard/src/lib/proxmox/index.ts
  - apps/dashboard/src/lib/ssh.ts
  - apps/dashboard/src/lib/queue/container-creation.ts
  - apps/dashboard/package.json
autonomous: true

must_haves:
  truths:
    - "Shared modules (Proxmox client, db.ts) can be imported by a standalone tsx process without crashing"
    - "SSHSession class can connect, execute commands, stream output, and upload files over SFTP"
    - "BullMQ queue is defined with typed job data and can accept new jobs from Next.js server actions"
    - "Worker dev script runs via tsx alongside Next.js via concurrently"
  artifacts:
    - path: "apps/dashboard/src/lib/ssh.ts"
      provides: "SSHSession class with exec, execStreaming, uploadFile methods and retry-with-backoff connect"
      contains: "SSHSession"
    - path: "apps/dashboard/src/lib/queue/container-creation.ts"
      provides: "BullMQ Queue instance, ContainerJobData type, ContainerJobResult type"
      contains: "containerCreationQueue"
  key_links:
    - from: "apps/dashboard/src/lib/queue/container-creation.ts"
      to: "apps/dashboard/src/lib/redis.ts"
      via: "Uses getRedis() for Queue connection"
      pattern: "getRedis"
    - from: "apps/dashboard/src/lib/ssh.ts"
      to: "ssh2"
      via: "Imports Client from ssh2"
      pattern: "import.*ssh2"
---

<objective>
Set up the infrastructure required by the container creation engine: remove `server-only` from shared modules so the worker process can import them, create the SSH session helper for post-creation deployment, and define the BullMQ queue with typed job data.

Purpose: The worker process runs as a standalone tsx script outside Next.js. It needs to import Proxmox client, Prisma, and SSH modules. The `server-only` guard currently prevents this. This plan unblocks all downstream work.

Output: Shared modules importable by worker, SSHSession class, BullMQ queue definition, dev scripts updated with concurrently.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-container-creation/03-RESEARCH.md

@apps/dashboard/src/lib/db.ts
@apps/dashboard/src/lib/redis.ts
@apps/dashboard/src/lib/proxmox/client.ts
@apps/dashboard/src/lib/proxmox/containers.ts
@apps/dashboard/src/lib/proxmox/tasks.ts
@apps/dashboard/src/lib/proxmox/index.ts
@apps/dashboard/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove server-only guards and create SSH session helper</name>
  <files>
    apps/dashboard/src/lib/db.ts
    apps/dashboard/src/lib/proxmox/client.ts
    apps/dashboard/src/lib/proxmox/containers.ts
    apps/dashboard/src/lib/proxmox/tasks.ts
    apps/dashboard/src/lib/proxmox/auth.ts
    apps/dashboard/src/lib/proxmox/nodes.ts
    apps/dashboard/src/lib/proxmox/storage.ts
    apps/dashboard/src/lib/proxmox/templates.ts
    apps/dashboard/src/lib/proxmox/index.ts
    apps/dashboard/src/lib/ssh.ts
  </files>
  <action>
**Part A: Remove `server-only` from shared modules**

In every file listed below, replace `import "server-only";` with a comment `// Server-side module — do not import from client components`. This allows the worker process (which runs via `tsx` outside Next.js) to import these modules.

Files to update (10 total):

- `src/lib/db.ts` — line 8
- `src/lib/proxmox/client.ts` — line 5
- `src/lib/proxmox/containers.ts` — line 5
- `src/lib/proxmox/tasks.ts` — line 5
- `src/lib/proxmox/auth.ts` — line 5
- `src/lib/proxmox/nodes.ts` — line 5
- `src/lib/proxmox/storage.ts` — line 5
- `src/lib/proxmox/templates.ts` — line 5
- `src/lib/proxmox/index.ts` — line 6

Leave `src/lib/session.ts` with `server-only` — the worker does NOT need session management and this file is only used in Next.js server actions/middleware.

**Part B: Create SSH session helper**

Create `src/lib/ssh.ts` with the `SSHSession` class. This wraps ssh2's Client with connection reuse, providing:

1. **Types:**

   ```ts
   interface SSHConfig {
     host: string;
     port?: number; // default 22
     username: string;
     password: string;
     readyTimeout?: number; // default 10000
   }

   interface SSHExecResult {
     stdout: string;
     stderr: string;
     code: number;
   }
   ```

2. **`SSHSession` class:**
   - Constructor takes `SSHConfig`, creates a new ssh2 `Client`, stores a `ready` promise that resolves on `"ready"` event and rejects on `"error"` event. Pass `readyTimeout` to connect options.
   - `async exec(command: string): Promise<SSHExecResult>` — Awaits ready, runs command, collects stdout/stderr as strings, resolves with `{ stdout, stderr, code }`.
   - `async execStreaming(command: string, onOutput: (line: string, isStderr: boolean) => void): Promise<number>` — Awaits ready, runs command, splits stdout/stderr data buffers by newlines (filter empty), calls `onOutput` per line. Returns exit code.
   - `async uploadFile(content: string | Buffer, remotePath: string, mode?: number): Promise<void>` — Awaits ready, opens SFTP session via `this.conn.sftp()`, creates write stream at `remotePath` with `mode` (default `0o644`), writes content, resolves on close.
   - `close(): void` — Calls `this.conn.end()`.

3. **`connectWithRetry(config: SSHConfig, options?: { maxAttempts?: number; initialDelay?: number }): Promise<SSHSession>`** — Standalone function for new containers where SSH takes seconds to start. Default: 5 attempts, 2000ms initial delay, exponential backoff (2s → 4s → 8s → 16s → 32s). On each failed attempt, log a message. Returns connected SSHSession. Throws after max attempts.

Do NOT add `server-only` — this module is imported by the worker process. Add comment: `// Server-side module — do not import from client components`.

Export: `SSHSession`, `SSHConfig`, `SSHExecResult`, `connectWithRetry`.
</action>
<verify> - `npx tsc --noEmit` passes in apps/dashboard (no type errors) - `grep -r "server-only" apps/dashboard/src/lib/ | grep -v session.ts | grep -v node_modules` returns NO results (only session.ts retains server-only) - `apps/dashboard/src/lib/ssh.ts` exists and exports SSHSession class
</verify>
<done> - All 9 shared modules have `server-only` replaced with comment - session.ts retains `server-only` (only used in Next.js context) - SSHSession class provides exec, execStreaming, uploadFile with connection reuse - connectWithRetry provides exponential backoff for new container SSH readiness
</done>
</task>

<task type="auto">
  <name>Task 2: BullMQ queue definition, types, and dev scripts</name>
  <files>
    apps/dashboard/src/lib/queue/container-creation.ts
    apps/dashboard/package.json
  </files>
  <action>
**Part A: Create BullMQ queue definition**

Create `src/lib/queue/container-creation.ts`:

1. **Import Queue from bullmq**, import `getRedis` from `../redis`.

2. **Type definitions:**

   ```ts
   /** Data passed to the container creation job */
   export interface ContainerJobData {
     containerId: string; // Prisma Container ID (cuid)
     nodeId: string; // Prisma ProxmoxNode ID
     templateId: string; // Prisma Template ID (for fetching scripts/files/packages)
     config: {
       hostname: string;
       vmid: number;
       memory: number; // MB
       swap: number; // MB
       cores: number;
       diskSize: number; // GB
       storage: string; // e.g., "local-lvm"
       bridge: string; // e.g., "vmbr0"
       ipConfig: string; // e.g., "ip=dhcp" or "ip=10.0.0.50/24,gw=10.0.0.1"
       nameserver?: string;
       rootPassword: string; // Plaintext for Proxmox API (encrypted in DB, decrypted before enqueue)
       sshPublicKey?: string;
       unprivileged: boolean;
       nesting: boolean;
       ostemplate: string; // e.g., "local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst"
       tags?: string;
     };
   }

   /** Progress event published via Redis Pub/Sub */
   export interface ContainerProgressEvent {
     type: "step" | "log" | "complete" | "error";
     step?: "creating" | "starting" | "deploying" | "syncing" | "finalizing";
     percent?: number; // 0-100
     message: string;
     timestamp: string; // ISO string
   }

   /** Result returned by the worker on job completion */
   export interface ContainerJobResult {
     success: boolean;
     containerId: string;
     vmid: number;
     error?: string;
   }
   ```

3. **Queue instance:**

   ```ts
   let queue: Queue<ContainerJobData, ContainerJobResult> | null = null;

   export function getContainerCreationQueue(): Queue<
     ContainerJobData,
     ContainerJobResult
   > {
     if (!queue) {
       queue = new Queue<ContainerJobData, ContainerJobResult>(
         "container-creation",
         {
           connection: getRedis(),
           defaultJobOptions: {
             removeOnComplete: { count: 100 },
             removeOnFail: { count: 500 },
             attempts: 1, // No auto-retry — container creation is not idempotent
           },
         },
       );
     }
     return queue;
   }
   ```

   Use lazy initialization pattern (same as getRedis) so the queue isn't created on module import — only when first used.

4. **Helper:** `getProgressChannel(containerId: string): string` — Returns `container:${containerId}:progress`. Export this so both worker and SSE route use the same channel naming.

Do NOT add `server-only` — this module is shared between Next.js and the worker process.

**Part B: Update package.json dev scripts**

Add `concurrently` as a devDependency. Then update scripts:

```json
{
  "scripts": {
    "dev": "next dev -p 3001",
    "dev:worker": "tsx --watch src/workers/container-creation.ts",
    "dev:all": "concurrently --names next,worker --prefix-colors blue,green \"pnpm dev\" \"pnpm dev:worker\""
  }
}
```

Keep existing `dev` script unchanged (still works standalone). Add `dev:worker` and `dev:all`. Do NOT create the worker file yet (Plan 02 does that) — just set up the script.

Run `pnpm add -D concurrently` from the apps/dashboard directory to install it.
</action>
<verify> - `npx tsc --noEmit` passes in apps/dashboard - `apps/dashboard/src/lib/queue/container-creation.ts` exists - `grep "concurrently" apps/dashboard/package.json` finds the dependency - `grep "dev:worker" apps/dashboard/package.json` finds the script - Module exports: `getContainerCreationQueue`, `getProgressChannel`, `ContainerJobData`, `ContainerProgressEvent`, `ContainerJobResult`
</verify>
<done> - BullMQ queue defined with typed job data, progress events, and result types - Lazy-initialized queue uses getRedis() for connection - Progress channel naming centralized via getProgressChannel() - concurrently installed and dev:worker/dev:all scripts added - Worker script path registered but file not yet created (Plan 02)
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all types valid, no server-only import errors
2. `grep -r "server-only" apps/dashboard/src/lib/ | grep -v session.ts | grep -v node_modules` — empty (only session.ts retains it)
3. Queue module exports typed interfaces and lazy queue getter
4. SSH module exports SSHSession with exec/execStreaming/uploadFile and connectWithRetry
5. package.json has concurrently, dev:worker, dev:all scripts
</verification>

<success_criteria>

- Worker process can import Proxmox client, Prisma db, SSH, and queue modules without `server-only` crashes
- SSHSession class provides connection-reuse pattern with exec, streaming, and SFTP upload
- connectWithRetry handles exponential backoff for new container SSH readiness
- BullMQ queue accepts typed ContainerJobData and returns ContainerJobResult
- Progress channel naming is consistent between worker and SSE route
- Dev scripts support running Next.js and worker simultaneously
  </success_criteria>

<output>
After completion, create `.planning/phases/03-container-creation/03-01-SUMMARY.md`
</output>
