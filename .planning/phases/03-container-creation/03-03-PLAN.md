---
phase: 03-container-creation
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/dashboard/src/lib/containers/schemas.ts
  - apps/dashboard/src/lib/containers/actions.ts
  - apps/dashboard/src/app/(dashboard)/containers/new/page.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/template-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/packages-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/scripts-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/review-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/wizard-stepper.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate to /containers/new and see a 5-step wizard with progress stepper"
    - "User can select a template from a card grid (or choose 'start from scratch')"
    - "User can configure hostname, VMID, password (with auto-generate and copy), resources, storage, network, and features"
    - "User can view and toggle template package buckets and see individual packages"
    - "User can view, enable/disable, and reorder template scripts"
    - "User can review all configuration on the final step and click Deploy"
    - "Clicking Deploy creates a Container record and enqueues a BullMQ job"
  artifacts:
    - path: "apps/dashboard/src/lib/containers/schemas.ts"
      provides: "Zod validation schemas for each wizard step"
      contains: "containerConfigSchema"
    - path: "apps/dashboard/src/lib/containers/actions.ts"
      provides: "createContainerAction server action that creates DB record and enqueues job"
      contains: "use server"
    - path: "apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx"
      provides: "Client component wizard shell with useState for step state management"
      contains: "use client"
    - path: "apps/dashboard/src/app/(dashboard)/containers/new/page.tsx"
      provides: "Server component that fetches initial data (templates, next VMID, bridges)"
      contains: "async function"
  key_links:
    - from: "apps/dashboard/src/app/(dashboard)/containers/new/page.tsx"
      to: "apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx"
      via: "Passes templates, nextVmid, bridges, storages as props"
      pattern: "ContainerWizard"
    - from: "apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx"
      to: "apps/dashboard/src/lib/containers/actions.ts"
      via: "Review step calls createContainerAction on deploy"
      pattern: "createContainerAction"
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/queue/container-creation.ts"
      via: "Enqueues job via getContainerCreationQueue().add()"
      pattern: "getContainerCreationQueue"
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Creates Container record via DatabaseService.createContainer()"
      pattern: "DatabaseService.createContainer"
---

<objective>
Build the 5-step container creation wizard UI at /containers/new. A server component page fetches initial data (templates, available storage/bridges, next VMID) and passes it to a client-side wizard that manages step state with useState. The final step calls a server action that creates a Container DB record and enqueues a BullMQ job.

Purpose: This is the user-facing entry point for container creation. The wizard collects all configuration needed for the creation engine (Plan 02) to build a container.

Output: Complete wizard UI with 5 steps, validation, and a server action that bridges the UI to the creation engine.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-container-creation/03-RESEARCH.md
@.planning/phases/03-container-creation/03-01-SUMMARY.md

@apps/dashboard/src/lib/queue/container-creation.ts
@apps/dashboard/src/lib/db.ts
@apps/dashboard/prisma/schema.prisma
@apps/dashboard/src/lib/proxmox/types.ts
@apps/dashboard/src/app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wizard Zod schemas, server action, and page shell</name>
  <files>
    apps/dashboard/src/lib/containers/schemas.ts
    apps/dashboard/src/lib/containers/actions.ts
    apps/dashboard/src/app/(dashboard)/containers/new/page.tsx
  </files>
  <action>
**Part A: Create Zod validation schemas**

Create `src/lib/containers/schemas.ts`:

```ts
import { z } from "zod";
```

Define schemas for each wizard step's data:

1. **`templateSelectionSchema`** — Step 1:

   ```ts
   export const templateSelectionSchema = z.object({
     templateId: z.string().nullable(), // null = "start from scratch"
     templateName: z.string().nullable(),
   });
   ```

2. **`containerConfigSchema`** — Step 2 (main config):

   ```ts
   export const containerConfigSchema = z
     .object({
       hostname: z
         .string()
         .min(1, "Hostname is required")
         .max(63)
         .regex(
           /^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/,
           "Invalid hostname format",
         ),
       vmid: z.coerce
         .number()
         .int()
         .min(100, "VMID must be ≥ 100")
         .max(999999999),
       rootPassword: z
         .string()
         .min(5, "Password must be at least 5 characters"),
       confirmPassword: z.string(),
       cores: z.coerce.number().int().min(1).max(128).default(1),
       memory: z.coerce
         .number()
         .int()
         .min(128, "Minimum 128 MB")
         .max(65536)
         .default(512),
       swap: z.coerce.number().int().min(0).max(65536).default(512),
       diskSize: z.coerce
         .number()
         .int()
         .min(1, "Minimum 1 GB")
         .max(10240)
         .default(8),
       storage: z.string().min(1, "Storage is required"),
       bridge: z.string().min(1, "Network bridge is required"),
       ipConfig: z.string().default("ip=dhcp"),
       nameserver: z.string().optional(),
       unprivileged: z.boolean().default(true),
       nesting: z.boolean().default(false),
       sshPublicKey: z.string().optional(),
       tags: z.string().optional(),
     })
     .refine((data) => data.rootPassword === data.confirmPassword, {
       message: "Passwords do not match",
       path: ["confirmPassword"],
     });
   ```

3. **`packageSelectionSchema`** — Step 3:

   ```ts
   export const packageSelectionSchema = z.object({
     enabledBuckets: z.array(z.string()), // bucket IDs that are enabled
     additionalPackages: z.string().optional(), // free-text additional packages
   });
   ```

4. **`scriptConfigSchema`** — Step 4:

   ```ts
   export const scriptConfigSchema = z.object({
     scripts: z.array(
       z.object({
         id: z.string(),
         name: z.string(),
         enabled: z.boolean(),
         order: z.number(),
       }),
     ),
   });
   ```

5. **`wizardStateSchema`** — Full wizard state combining all steps:

   ```ts
   export const wizardStateSchema = z.object({
     step: z.number().min(1).max(5),
     template: templateSelectionSchema.nullable(),
     config: containerConfigSchema.nullable(),
     packages: packageSelectionSchema.nullable(),
     scripts: scriptConfigSchema.nullable(),
   });
   ```

6. **Export inferred types:**
   ```ts
   export type TemplateSelection = z.infer<typeof templateSelectionSchema>;
   export type ContainerConfig = z.infer<typeof containerConfigSchema>;
   export type PackageSelection = z.infer<typeof packageSelectionSchema>;
   export type ScriptConfig = z.infer<typeof scriptConfigSchema>;
   export type WizardState = z.infer<typeof wizardStateSchema>;
   ```

**Part B: Create server action**

Create `src/lib/containers/actions.ts`:

```ts
"use server";
```

Import: `DatabaseService`, `encrypt` from `../encryption`, `getContainerCreationQueue` from `../queue/container-creation`, Zod schemas.

**`createContainerAction(formData: { ... }): Promise<{ success: boolean; containerId?: string; error?: string }>`:**

1. Parse and validate the full wizard data using Zod (combine config fields)
2. Determine the Proxmox node to use — for now, use the first node from `DatabaseService.listNodes()`. If no nodes configured, return error.
3. Encrypt the root password via `encrypt(rootPassword)`
4. Create Container record via `DatabaseService.createContainer({ vmid, rootPassword: encryptedPassword, nodeId: node.id, templateId: data.templateId || undefined })`
5. Determine `ostemplate` — if template selected, fetch template from DB and use its `osTemplate` field to construct the full path (e.g., `local:vztmpl/${template.osTemplate}_amd64.tar.zst`). If "start from scratch", require user to have specified it (or use a default like `local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst`). Actually, for "start from scratch", the osTemplate selection should be in Step 2. Add a `ostemplate` field to the config schema for this case. For templates, auto-fill from template data.
6. Enqueue BullMQ job:
   ```ts
   const queue = getContainerCreationQueue();
   await queue.add("create-container", {
     containerId: container.id,
     nodeId: node.id,
     templateId: data.templateId || "",
     config: {
       hostname,
       vmid,
       memory,
       swap,
       cores,
       diskSize,
       storage,
       bridge,
       ipConfig,
       nameserver,
       rootPassword, // Plaintext — Proxmox API needs it. Encrypted version is in DB.
       sshPublicKey,
       unprivileged,
       nesting,
       ostemplate,
       tags,
     },
   });
   ```
7. Return `{ success: true, containerId: container.id }`
8. Wrap in try/catch — on error return `{ success: false, error: "Failed to create container" }` (generic message, log actual error)

**Also create helper server actions for fetching wizard data:**

**`getWizardData(): Promise<{ templates, storages, bridges, nextVmid }>`:**

- Fetch all templates from DB with `prisma.template.findMany({ include: { packages: true, scripts: { orderBy: { order: "asc" } } } })`
- Fetch the first ProxmoxNode, create client, fetch storages via `storage.listStorage(client, node.name)` and bridges via `client.get(\`/nodes/${node.name}/network\`)` (filter for type "bridge")
- Get next VMID via `client.get("/cluster/nextid")` (returns number)
- Return all data. If no node configured, return empty arrays with a flag.

**Part C: Create server component page**

Create `src/app/(dashboard)/containers/new/page.tsx`:

```tsx
import { getWizardData } from "@/lib/containers/actions";
import { ContainerWizard } from "./container-wizard";

export default async function NewContainerPage() {
  const { templates, storages, bridges, nextVmid } = await getWizardData();

  return (
    <div className="flex-1 space-y-6 p-6">
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Create Container</h1>
        <p className="text-muted-foreground">
          Configure and deploy a new LXC container
        </p>
      </div>
      <ContainerWizard
        templates={templates}
        storages={storages}
        bridges={bridges}
        nextVmid={nextVmid}
      />
    </div>
  );
}
```

This is a server component that fetches data, then delegates to the client wizard component.
</action>
<verify> - `npx tsc --noEmit` passes - `apps/dashboard/src/lib/containers/schemas.ts` exports all schema types - `apps/dashboard/src/lib/containers/actions.ts` has "use server" and exports createContainerAction, getWizardData - `apps/dashboard/src/app/(dashboard)/containers/new/page.tsx` exists as server component
</verify>
<done> - Zod schemas validate each wizard step independently - Password confirmation refine validates passwords match - Server action creates encrypted Container record and enqueues BullMQ job - getWizardData fetches templates, storages, bridges, nextVmid from Proxmox API - Server component page fetches data and passes to wizard
</done>
</task>

<task type="auto">
  <name>Task 2: Wizard shell, stepper, template step, and configure step</name>
  <files>
    apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/wizard-stepper.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/template-step.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx
  </files>
  <action>
**Part A: Wizard stepper indicator**

Create `wizard-stepper.tsx` — a horizontal step progress indicator:

```tsx
"use client";

const STEPS = [
  { number: 1, label: "Template" },
  { number: 2, label: "Configure" },
  { number: 3, label: "Packages" },
  { number: 4, label: "Scripts" },
  { number: 5, label: "Review" },
];
```

Visual: Horizontal row of circles with labels and connecting lines. Current step is highlighted (primary color), completed steps show a checkmark, future steps are muted. Use Tailwind classes. Keep it simple — no animations.

Props: `{ currentStep: number; completedSteps: number[] }`.

**Part B: ContainerWizard shell**

Create `container-wizard.tsx`:

```tsx
"use client";

import { useState, useTransition } from "react";
import { useRouter } from "next/navigation";
```

Props type:

```ts
interface ContainerWizardProps {
  templates: Array<{
    id: string;
    name: string;
    description: string | null;
    osTemplate: string | null;
    cores: number | null;
    memory: number | null;
    swap: number | null;
    diskSize: number | null;
    storage: string | null;
    bridge: string | null;
    unprivileged: boolean;
    nesting: boolean;
    tags: string | null;
    packages: Array<{ id: string; name: string; manager: string }>;
    scripts: Array<{
      id: string;
      name: string;
      order: number;
      enabled: boolean;
      description: string | null;
    }>;
  }>;
  storages: Array<{ storage: string; type: string; content: string }>;
  bridges: Array<{ iface: string; type: string }>;
  nextVmid: number;
}
```

State management:

```tsx
const [step, setStep] = useState(1);
const [templateData, setTemplateData] = useState<TemplateSelection | null>(
  null,
);
const [configData, setConfigData] = useState<ContainerConfig | null>(null);
const [packagesData, setPackagesData] = useState<PackageSelection | null>(null);
const [scriptsData, setScriptsData] = useState<ScriptConfig | null>(null);
const [deployResult, setDeployResult] = useState<{
  containerId: string;
} | null>(null);
const [isPending, startTransition] = useTransition();
const router = useRouter();
```

Render: WizardStepper at top, then conditionally render step components based on `step` value. Each step receives its data (for pre-filling when navigating back) and callbacks: `onNext(data)` and `onBack()`.

When a template is selected in Step 1, pre-populate Step 2 defaults from the template (cores, memory, swap, diskSize, storage, bridge). Pre-populate Step 3 with template's package buckets. Pre-populate Step 4 with template's scripts.

When the Review step calls deploy, call `createContainerAction` via `startTransition`, then navigate to a progress page: `router.push(\`/containers/${result.containerId}/progress\`)`.

**Part C: Template step (Step 1)**

Create `steps/template-step.tsx`:

- Grid of Card components showing available templates (name, description, tags as Badge components)
- Each card is clickable — selects the template
- Special "Start from Scratch" card with a plus icon
- "Next" button at bottom (disabled until template is selected or "from scratch" chosen)
- Props: `{ templates, data: TemplateSelection | null, onNext: (data: TemplateSelection) => void }`

**Part D: Configure step (Step 2)**

Create `steps/configure-step.tsx`:

- Form with sections:
  - **Identity:** hostname (Input), VMID (Input, pre-filled with nextVmid)
  - **Access:** root password (Input type="password") with a "Generate" button that creates a random 16-char password (use `crypto.getRandomValues` or a simple charset-based generator) and a "Copy" button (using `navigator.clipboard.writeText`) to copy the generated password. Both buttons sit inline next to the password input. When generated, auto-fill the confirm password field too. Confirm password (Input type="password"). SSH public key (Textarea, optional).
  - **Resources:** cores (Input number), memory MB (Input number), swap MB (Input number), disk size GB (Input number)
  - **Storage & Network:** storage (Select from storages prop), bridge (Select from bridges prop), IP config (Input, default "ip=dhcp"), nameserver (Input, optional)
  - **Features:** unprivileged (Switch), nesting (Switch)
  - **Tags:** free-text Input
- Validate using `containerConfigSchema` on "Next" click. Show inline errors per field.
- "Back" and "Next" buttons
- Props: `{ data, defaultsFromTemplate, storages, bridges, nextVmid, onNext, onBack }`

**Styling:** Use shadcn/ui components (Card, Button, Input, Label, Select, Switch, Badge, Textarea, Separator). Use Tailwind for layout — responsive grid for template cards (2-3 cols on lg, 1 on mobile). Keep form sections visually separated with Separator or Card boundaries.

**Do NOT install any additional packages** — use only existing shadcn/ui components and Tailwind.
</action>
<verify> - `npx tsc --noEmit` passes - All 4 files exist (container-wizard.tsx, wizard-stepper.tsx, template-step.tsx, configure-step.tsx) - `grep "use client" apps/dashboard/src/app/\(dashboard\)/containers/new/container-wizard.tsx` confirms client component - configure-step.tsx has password generate and copy functionality - Navigate to /containers/new in the browser shows wizard shell with first two steps functional
</verify>
<done> - Wizard shell with useState state management renders at /containers/new - Horizontal step indicator shows 5 steps with current/completed/pending states - Step 1: Template selection grid with "start from scratch" option - Step 2: Full configuration form with Zod validation, inline errors, password generate + copy buttons - Template defaults pre-populate Step 2 when a template is selected - Navigation (back/next) preserves state
</done>
</task>

<task type="auto">
  <name>Task 3: Packages, scripts, and review step components</name>
  <files>
    apps/dashboard/src/app/(dashboard)/containers/new/steps/packages-step.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/scripts-step.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/review-step.tsx
  </files>
  <action>
**Part A: Packages step (Step 3)**

Create `steps/packages-step.tsx`:

- List package buckets from selected template as toggleable cards (Checkbox + bucket name + package count)
- Expanding each bucket shows individual package names as badges
- "Additional packages" Textarea for extra packages (one per line)
- If "from scratch" was selected, show just the additional packages textarea
- "Back" and "Next" buttons
- Props: `{ data, templatePackages, onNext, onBack }`

**Part B: Scripts step (Step 4)**

Create `steps/scripts-step.tsx`:

- List template scripts in order, each with:
  - Switch to enable/disable
  - Script name and description
  - Drag handle for reordering (use simple up/down buttons instead of drag — keep it simple, no extra deps)
- If "from scratch", show message "No scripts configured" with just nav buttons
- "Back" and "Next" buttons
- Props: `{ data, templateScripts, onNext, onBack }`

**Part C: Review step (Step 5)**

Create `steps/review-step.tsx`:

- Read-only summary of all configuration:
  - Template name (or "From Scratch")
  - Container config (hostname, VMID, resources, network, features)
  - Enabled packages (count by bucket)
  - Enabled scripts (list)
- "Deploy" button (primary, prominent) and "Back" button
- Show loading state (Spinner) when deploy is pending via `isPending` prop
- **Note:** "Save as Template" functionality is deferred to a future enhancement. Do NOT implement a save-as-template button in this phase. Add a code comment `// TODO: Save as Template button — deferred to future enhancement` in the review step for discoverability.
- Props: `{ wizardState (all data), isPending, onDeploy, onBack }`

**Styling:** Use shadcn/ui components (Card, Button, Checkbox, Badge, Switch, Textarea, Separator). Use Tailwind for layout. Keep form sections visually separated.

**Do NOT install any additional packages** — use only existing shadcn/ui components and Tailwind.
</action>
<verify> - `npx tsc --noEmit` passes - All 3 step files exist (packages-step.tsx, scripts-step.tsx, review-step.tsx) - `grep "TODO.*Save as Template" apps/dashboard/src/app/\(dashboard\)/containers/new/steps/review-step.tsx` confirms deferral comment - Full wizard is navigable from Step 1 through Step 5
</verify>
<done> - Step 3: Package bucket toggles with expandable package lists - Step 4: Script enable/disable with up/down reorder buttons - Step 5: Review summary with Deploy button and Save-as-Template deferred with TODO comment - Template defaults pre-populate Steps 3-4 when a template is selected - Deploy button calls server action and navigates to progress page - All navigation (back/next) preserves state
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all types valid across schemas, actions, and components
2. Zod schemas provide per-step validation with meaningful error messages
3. Server action creates Container record with encrypted password and enqueues BullMQ job
4. Wizard state persists across forward/back navigation
5. Template selection pre-fills defaults in subsequent steps
6. All form inputs use shadcn/ui components consistently
7. Deploy triggers server action and redirects to progress page
8. Password auto-generate creates random password and copies to clipboard
9. Review step has TODO comment for Save as Template deferral
</verification>

<success_criteria>

- /containers/new renders a 5-step wizard with step indicator
- Template grid shows available templates from database
- Configuration form validates all fields via Zod before allowing Next
- Password auto-generate button creates random 16-char password with clipboard copy
- Package and script steps reflect selected template's data
- Review step shows complete summary of all configuration (Save as Template deferred)
- Deploy creates Container DB record + enqueues BullMQ job
- User is redirected to progress page after deploy
  </success_criteria>

<output>
After completion, create `.planning/phases/03-container-creation/03-03-SUMMARY.md`
</output>
