---
phase: 03-container-creation
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - apps/dashboard/src/app/api/containers/[id]/progress/route.ts
  - apps/dashboard/src/hooks/use-container-progress.ts
  - apps/dashboard/src/app/(dashboard)/containers/[id]/progress/page.tsx
  - apps/dashboard/src/app/(dashboard)/containers/[id]/progress/progress-stepper.tsx
  - apps/dashboard/src/app/(dashboard)/containers/[id]/progress/log-viewer.tsx
autonomous: true

must_haves:
  truths:
    - "SSE endpoint streams real-time progress events for a container creation job"
    - "On SSE connect, existing ContainerEvent rows are replayed before live subscription"
    - "useContainerProgress hook provides reactive events array and connection status"
    - "Progress page shows a phase stepper with current/completed/pending phases"
    - "Progress page shows a scrollable log viewer with real-time log lines"
    - "Progress page shows completion state with link to container or error details"
    - "If container is already ready/error when page loads, progress is shown immediately without SSE"
  artifacts:
    - path: "apps/dashboard/src/app/api/containers/[id]/progress/route.ts"
      provides: "SSE endpoint with Redis Pub/Sub subscription and ContainerEvent replay"
      contains: "text/event-stream"
    - path: "apps/dashboard/src/hooks/use-container-progress.ts"
      provides: "React hook wrapping EventSource for container progress"
      contains: "useContainerProgress"
    - path: "apps/dashboard/src/app/(dashboard)/containers/[id]/progress/page.tsx"
      provides: "Progress tracking page with stepper, logs, and completion state"
      contains: "useContainerProgress"
  key_links:
    - from: "apps/dashboard/src/app/api/containers/[id]/progress/route.ts"
      to: "apps/dashboard/src/lib/queue/container-creation.ts"
      via: "Uses getProgressChannel for Redis Pub/Sub channel name"
      pattern: "getProgressChannel"
    - from: "apps/dashboard/src/app/api/containers/[id]/progress/route.ts"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Queries ContainerEvent for replay on connect"
      pattern: "containerEvent\\.findMany|getContainerEvents"
    - from: "apps/dashboard/src/hooks/use-container-progress.ts"
      to: "apps/dashboard/src/app/api/containers/[id]/progress/route.ts"
      via: "EventSource connects to SSE endpoint"
      pattern: "EventSource.*api/containers"
    - from: "apps/dashboard/src/app/(dashboard)/containers/[id]/progress/page.tsx"
      to: "apps/dashboard/src/hooks/use-container-progress.ts"
      via: "Uses hook for reactive progress state"
      pattern: "useContainerProgress"
---

<objective>
Build the real-time progress tracking system: an SSE endpoint that streams container creation events via Redis Pub/Sub, a React hook that connects to it, and a progress page UI with phase stepper, log viewer, and completion states.

Purpose: After the user clicks Deploy in the wizard, they're redirected here to watch their container being created in real-time. This closes the loop between the creation engine (Plan 02) and the user.

Output: SSE route handler, useContainerProgress hook, and a progress tracking page with visual stepper and log viewer.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-container-creation/03-RESEARCH.md
@.planning/phases/03-container-creation/03-01-SUMMARY.md
@.planning/phases/03-container-creation/03-02-SUMMARY.md
@.planning/phases/03-container-creation/03-03-SUMMARY.md

@apps/dashboard/src/lib/queue/container-creation.ts
@apps/dashboard/src/lib/redis.ts
@apps/dashboard/src/lib/db.ts
@apps/dashboard/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSE endpoint and useContainerProgress hook</name>
  <files>
    apps/dashboard/src/app/api/containers/[id]/progress/route.ts
    apps/dashboard/src/hooks/use-container-progress.ts
  </files>
  <action>
**Part A: SSE route handler**

Create `src/app/api/containers/[id]/progress/route.ts`:

```ts
import { type NextRequest } from "next/server";
import Redis from "ioredis";
import { getProgressChannel } from "@/lib/queue/container-creation";
import { DatabaseService } from "@/lib/db";

export const dynamic = "force-dynamic";
```

**`GET` handler:**

1. Extract container ID from params (Next.js 15 pattern: `params` is a `Promise`):

   ```ts
   export async function GET(
     request: NextRequest,
     { params }: { params: Promise<{ id: string }> },
   ) {
     const { id } = await params;
   ```

2. Verify the container exists:

   ```ts
   const container = await DatabaseService.getContainerById(id);
   if (!container) {
     return new Response("Container not found", { status: 404 });
   }
   ```

3. If container is already in terminal state (`ready` or `error`), return existing events without opening SSE stream:

   ```ts
   if (container.lifecycle === "ready" || container.lifecycle === "error") {
     const events = await DatabaseService.getContainerEvents(id);
     const formatted = events.map((e) => ({
       type: container.lifecycle === "ready" ? "complete" : "error",
       step: undefined,
       percent: container.lifecycle === "ready" ? 100 : undefined,
       message: e.message,
       timestamp: e.createdAt.toISOString(),
     }));
     // Return as JSON instead of SSE — client hook handles both
     return Response.json({ events: formatted, status: container.lifecycle });
   }
   ```

   Actually, better approach: always use SSE format for consistency. The hook checks container status first. Let's keep the SSE route always returning a stream:

4. Create ReadableStream:

   ```ts
   const encoder = new TextEncoder();
   const stream = new ReadableStream({
     async start(controller) {
       // Helper to send SSE event
       const send = (data: unknown) => {
         try {
           controller.enqueue(
             encoder.encode(`data: ${JSON.stringify(data)}\n\n`),
           );
         } catch {
           // Stream may be closed
         }
       };

       // Step 1: Replay existing ContainerEvent rows
       const existingEvents = await DatabaseService.getContainerEvents(id);
       for (const event of existingEvents) {
         send({
           type: "replay",
           eventType: event.type,
           message: event.message,
           metadata: event.metadata ? JSON.parse(event.metadata) : null,
           timestamp: event.createdAt.toISOString(),
         });
       }

       // Check if container already finished
       if (container.lifecycle === "ready") {
         send({ type: "complete", percent: 100, message: "Container ready!" });
         controller.close();
         return;
       }
       if (container.lifecycle === "error") {
         send({ type: "error", message: "Container creation failed" });
         controller.close();
         return;
       }

       // Step 2: Subscribe to Redis Pub/Sub for live events
       const subscriber = new Redis(process.env.REDIS_URL!);
       const channel = getProgressChannel(id);

       subscriber.subscribe(channel);
       subscriber.on("message", (ch, message) => {
         if (ch === channel) {
           const event = JSON.parse(message);
           send(event);

           // Close stream on terminal events
           if (event.type === "complete" || event.type === "error") {
             subscriber.unsubscribe(channel);
             subscriber.quit();
             controller.close();
           }
         }
       });

       // Step 3: Heartbeat every 15 seconds
       const heartbeat = setInterval(() => {
         try {
           controller.enqueue(encoder.encode(": heartbeat\n\n"));
         } catch {
           clearInterval(heartbeat);
         }
       }, 15000);

       // Step 4: Cleanup on client disconnect
       request.signal.addEventListener("abort", () => {
         clearInterval(heartbeat);
         subscriber.unsubscribe(channel).catch(() => {});
         subscriber.quit().catch(() => {});
         try {
           controller.close();
         } catch {}
       });
     },
   });
   ```

5. Return Response with SSE headers:
   ```ts
   return new Response(stream, {
     headers: {
       "Content-Type": "text/event-stream",
       "Cache-Control": "no-cache, no-transform",
       Connection: "keep-alive",
       "X-Accel-Buffering": "no",
     },
   });
   ```

**Part B: useContainerProgress hook**

Create `src/hooks/use-container-progress.ts`:

```tsx
"use client";

import { useEffect, useState, useRef, useCallback } from "react";
```

Types:

```ts
export interface ProgressEvent {
  type: "replay" | "step" | "log" | "complete" | "error";
  step?: "creating" | "starting" | "deploying" | "syncing" | "finalizing";
  percent?: number;
  message: string;
  timestamp?: string;
  eventType?: string; // For replay events
  metadata?: { step?: string; percent?: number };
}

export type ConnectionStatus =
  | "idle"
  | "connecting"
  | "streaming"
  | "complete"
  | "error"
  | "disconnected";
```

**`useContainerProgress(containerId: string | null)`:**

State:

```ts
const [events, setEvents] = useState<ProgressEvent[]>([]);
const [status, setStatus] = useState<ConnectionStatus>("idle");
const [currentStep, setCurrentStep] = useState<string | null>(null);
const [percent, setPercent] = useState(0);
const eventSourceRef = useRef<EventSource | null>(null);
```

Effect (depends on containerId):

1. If no containerId, return early
2. Set status to "connecting"
3. Create `EventSource` pointing to `/api/containers/${containerId}/progress`
4. `onmessage`: Parse event data, append to events array. Update `currentStep` and `percent` from step events. On "complete" → set status to "complete", close EventSource. On "error" → set status to "error", close EventSource. On first event → set status to "streaming".
5. `onerror`: Set status to "disconnected" (EventSource auto-reconnects, but for a one-shot stream this likely means the stream ended). Close EventSource.
6. Cleanup: close EventSource on unmount

Return: `{ events, status, currentStep, percent }`

Derive computed values:

```ts
const logs = events.filter((e) => e.type === "log");
const steps = events.filter((e) => e.type === "step" || e.type === "replay");
```

Return logs and steps as separate arrays for convenience.
</action>
<verify> - `npx tsc --noEmit` passes - `apps/dashboard/src/app/api/containers/[id]/progress/route.ts` exists - `grep "text/event-stream" apps/dashboard/src/app/api/containers/\\[id\\]/progress/route.ts` confirms SSE headers - `grep "force-dynamic" apps/dashboard/src/app/api/containers/\\[id\\]/progress/route.ts` confirms dynamic route - `apps/dashboard/src/hooks/use-container-progress.ts` exports useContainerProgress - `grep "EventSource" apps/dashboard/src/hooks/use-container-progress.ts` confirms EventSource usage
</verify>
<done> - SSE endpoint replays existing ContainerEvent rows on connect - SSE endpoint subscribes to Redis Pub/Sub for live events - SSE endpoint handles terminal states (already ready/error) without hanging - 15-second heartbeat keeps connection alive through proxies - Client disconnect triggers proper Redis unsubscribe cleanup - useContainerProgress hook provides events, status, currentStep, percent - Hook automatically closes on terminal events (complete/error)
</done>
</task>

<task type="auto">
  <name>Task 2: Progress tracking page with stepper, log viewer, and completion states</name>
  <files>
    apps/dashboard/src/app/(dashboard)/containers/[id]/progress/page.tsx
    apps/dashboard/src/app/(dashboard)/containers/[id]/progress/progress-stepper.tsx
    apps/dashboard/src/app/(dashboard)/containers/[id]/progress/log-viewer.tsx
  </files>
  <action>
**Part A: Progress stepper component**

Create `progress-stepper.tsx`:

```tsx
"use client";
```

The 5 pipeline phases displayed as a vertical or horizontal stepper:

```ts
const PIPELINE_PHASES = [
  {
    key: "creating",
    label: "Create Container",
    description: "Provisioning LXC on Proxmox",
  },
  {
    key: "starting",
    label: "Start Container",
    description: "Booting container",
  },
  {
    key: "deploying",
    label: "Deploy Files",
    description: "Uploading template files via SSH",
  },
  {
    key: "syncing",
    label: "Run Scripts",
    description: "Executing setup scripts",
  },
  { key: "finalizing", label: "Finalize", description: "Completing setup" },
];
```

Props: `{ currentStep: string | null; percent: number; status: ConnectionStatus }`

Visual:

- Each phase shows: circle icon + label + description
- States: completed (checkmark, green), active (spinner/pulse, blue), pending (muted circle, gray), error (X icon, red)
- Determine state: phases before currentStep are "completed", currentStep is "active", phases after are "pending". If status is "error", the currentStep phase shows "error".
- Overall progress bar below the stepper showing percent (0-100%)

Use shadcn/ui Card as container. Use Tailwind for the step indicators (flex column, connecting lines between steps). Use lucide-react icons: `Check`, `Circle`, `Loader2`, `XCircle`.

**Part B: Log viewer component**

Create `log-viewer.tsx`:

```tsx
"use client";

import { useEffect, useRef } from "react";
```

Props: `{ logs: Array<{ message: string; timestamp?: string }> }`

Visual:

- Dark background container (bg-zinc-950) resembling a terminal
- Monospace font (font-mono, text-sm)
- Each log line prefixed with a muted timestamp (if available)
- Auto-scroll to bottom as new logs arrive (using ref on container div, `scrollTop = scrollHeight` on log array change)
- Max height with overflow-y-auto (e.g., `max-h-[400px]`)
- Show "Waiting for logs..." placeholder when empty

useEffect that scrolls to bottom when `logs.length` changes.

**Part C: Progress page**

Create `page.tsx`:

```tsx
import { ProgressPageClient } from "./progress-page-client";
```

Actually, since the page needs the container ID from the URL, and `useContainerProgress` is a client hook, make this a client component or use a server/client split:

Option: Server component that reads params and renders client component.

```tsx
// page.tsx (server component)
import { ProgressContent } from "./progress-content";

export default async function ContainerProgressPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  return <ProgressContent containerId={id} />;
}
```

Then create the actual client component inline in the same file or as a separate file. Since we already have the file list, make `page.tsx` the server component wrapper and put the client logic directly inside it using a client component import.

Actually, simplify: make `page.tsx` a client component with `"use client"` and read params via `useParams()`:

```tsx
"use client";

import { useParams } from "next/navigation";
import { useContainerProgress } from "@/hooks/use-container-progress";
import { ProgressStepper } from "./progress-stepper";
import { LogViewer } from "./log-viewer";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
```

Layout:

```
┌─────────────────────────────────────────────┐
│ Creating Container                    [Back] │
├─────────────────────────────────────────────┤
│                                             │
│  ┌──────────────────────────────────────┐   │
│  │ Progress Stepper (5 phases)          │   │
│  │ ● Create ● Start ● Deploy ...       │   │
│  │ ▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░░ 45%          │   │
│  └──────────────────────────────────────┘   │
│                                             │
│  ┌──────────────────────────────────────┐   │
│  │ Log Output                           │   │
│  │ > Creating LXC container...          │   │
│  │ > Container created (VMID 150)       │   │
│  │ > Starting container...              │   │
│  │ > Running 00-pre-checks.sh...        │   │
│  └──────────────────────────────────────┘   │
│                                             │
│  ┌──────────────────────────────────────┐   │
│  │ ✓ Container Ready!                   │   │
│  │ [View Container] [Create Another]    │   │
│  └──────────────────────────────────────┘   │
│                                             │
└─────────────────────────────────────────────┘
```

State handling:

- Call `useContainerProgress(containerId)` to get events, status, currentStep, percent, logs, steps
- Render ProgressStepper with currentStep and percent
- Render LogViewer with logs
- **Completion state** (status === "complete"): Show success Card with green checkmark, "Container Ready!" message, buttons: "View Container" (link to `/containers/${id}`), "Create Another" (link to `/containers/new`)
- **Error state** (status === "error"): Show error Card with red X, error message from last error event, buttons: "Try Again" (link to `/containers/new`), "View Details" (expand to show full error)
- **Connecting state**: Show Skeleton loaders for stepper and log viewer
- **Streaming state**: Normal rendering with live updates

Page header: "Creating Container" title with the container ID or hostname in subtitle. Back button linking to /containers.

Use shadcn/ui: Card, Button, Badge, Skeleton. Lucide icons: `CheckCircle2`, `XCircle`, `ArrowLeft`.
</action>
<verify> - `npx tsc --noEmit` passes - All 3 files exist in the containers/[id]/progress/ directory - `grep "useContainerProgress" apps/dashboard/src/app/\(dashboard\)/containers/\\[id\\]/progress/page.tsx` confirms hook usage - progress-stepper.tsx renders 5 pipeline phases - log-viewer.tsx has auto-scroll behavior - Page handles all states: connecting, streaming, complete, error
</verify>
<done> - Progress stepper shows 5 pipeline phases with visual state (completed/active/pending/error) - Overall progress bar shows 0-100% completion - Log viewer auto-scrolls and displays real-time log output in terminal-style UI - Completion state shows success message with navigation links - Error state shows error details with retry option - Connecting state shows skeleton placeholders - All components use shadcn/ui and Tailwind consistently
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all types valid across route, hook, and components
2. SSE endpoint returns text/event-stream with proper headers
3. SSE replays existing events on connect, then subscribes for live
4. SSE cleans up Redis subscriber on client disconnect
5. Hook manages EventSource lifecycle with proper cleanup
6. Progress page shows stepper, logs, and terminal states
7. Page handles all edge cases: already-complete container, errors, disconnects
</verification>

<success_criteria>

- Navigating to /containers/:id/progress opens SSE connection and receives events
- Progress stepper updates in real-time as worker moves through phases
- Log viewer shows streaming output from SSH script execution
- Completion state shows success with navigation to container detail
- Error state shows meaningful error with retry option
- Late subscriber sees replayed events + catches up to live stream
- Closing the page cleanly disconnects SSE and Redis subscriber
  </success_criteria>

<output>
After completion, create `.planning/phases/03-container-creation/03-04-SUMMARY.md`
</output>
