---
phase: 03-container-creation
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/src/lib/proxmox/templates.ts
  - apps/dashboard/src/lib/proxmox/schemas.ts
  - apps/dashboard/src/lib/containers/actions.ts
  - apps/dashboard/src/lib/containers/schemas.ts
  - apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/page.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx
  - apps/dashboard/src/app/(dashboard)/containers/new/steps/review-step.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User sees a dropdown of downloaded OS templates in the Configure step"
    - "User can select an OS template and it flows through to container creation"
    - "Container creation succeeds with the selected OS template (no hardcoded fallback)"
    - "Review step shows the selected OS template name"
  artifacts:
    - path: "apps/dashboard/src/lib/proxmox/templates.ts"
      provides: "listDownloadedTemplates function for fetching vztmpl content from storage"
      exports: ["listDownloadedTemplates", "listTemplates"]
    - path: "apps/dashboard/src/lib/containers/actions.ts"
      provides: "WizardData with osTemplates field populated from Proxmox storage"
      contains: "osTemplates"
    - path: "apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx"
      provides: "OS template Select dropdown in the Configure step form"
      contains: "ostemplate"
  key_links:
    - from: "apps/dashboard/src/lib/containers/actions.ts"
      to: "apps/dashboard/src/lib/proxmox/templates.ts"
      via: "listDownloadedTemplates call in getWizardData"
      pattern: "listDownloadedTemplates"
    - from: "apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx"
      to: "osTemplates prop"
      via: "Select dropdown bound to ostemplate form field"
      pattern: "ostemplate.*Select"
    - from: "apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx"
      to: "createContainerAction"
      via: "configData.ostemplate passed in deploy payload"
      pattern: "ostemplate.*configData"
---

<objective>
Add OS template selector to the container creation wizard to fix the blocker where container creation fails because ostemplate defaults to a hardcoded Debian path that doesn't exist on the user's Proxmox storage.

Purpose: Close the UAT blocker (test #15) — containers cannot be created end-to-end without selecting a real OS template that exists on storage.
Output: Working OS template dropdown in Configure step, wired through the full wizard data flow.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-container-creation/03-UAT.md

@apps/dashboard/src/lib/proxmox/templates.ts
@apps/dashboard/src/lib/proxmox/schemas.ts
@apps/dashboard/src/lib/proxmox/storage.ts
@apps/dashboard/src/lib/proxmox/types.ts
@apps/dashboard/src/lib/proxmox/index.ts
@apps/dashboard/src/lib/containers/actions.ts
@apps/dashboard/src/lib/containers/schemas.ts
@apps/dashboard/src/app/(dashboard)/containers/new/page.tsx
@apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx
@apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx
@apps/dashboard/src/app/(dashboard)/containers/new/steps/review-step.tsx
@apps/dashboard/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add downloaded template fetching to Proxmox client and wire into getWizardData</name>
  <files>
    apps/dashboard/src/lib/proxmox/schemas.ts
    apps/dashboard/src/lib/proxmox/templates.ts
    apps/dashboard/src/lib/containers/actions.ts
    apps/dashboard/src/lib/containers/schemas.ts
  </files>
  <action>
**1. Add a Zod schema for storage content items** in `apps/dashboard/src/lib/proxmox/schemas.ts`:

Add a `StorageContentSchema` after the existing `StorageSchema`:

```ts
export const StorageContentSchema = z.object({
  volid: z.string(), // e.g. "local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst"
  format: z.string(), // e.g. "tar.zst", "tar.gz"
  size: z.number(), // bytes
  content: z.string(), // "vztmpl"
});
```

Use `.passthrough()` since Proxmox may return extra fields.

**2. Add type export** in `apps/dashboard/src/lib/proxmox/types.ts`:

```ts
export type ProxmoxStorageContent = z.infer<typeof StorageContentSchema>;
```

Import `StorageContentSchema` in the type imports.

**3. Add `listDownloadedTemplates` function** in `apps/dashboard/src/lib/proxmox/templates.ts`:

```ts
export async function listDownloadedTemplates(
  client: ProxmoxClient,
  node: string,
  storage: string,
): Promise<ProxmoxStorageContent[]> {
  return client.get(
    `/nodes/${node}/storage/${storage}/content?content=vztmpl`,
    z.array(StorageContentSchema),
  );
}
```

Import `StorageContentSchema` from `./schemas` and `ProxmoxStorageContent` from `./types`.

**4. Update `WizardData` interface and `getWizardData()`** in `apps/dashboard/src/lib/containers/actions.ts`:

Add a new type and field:

```ts
export interface WizardOsTemplate {
  volid: string; // "local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst"
  name: string; // "debian-12-standard_12.7-1_amd64" (human-readable, extracted from volid)
  size: number; // bytes
}
```

Add `osTemplates: WizardOsTemplate[]` to the `WizardData` interface.

In the `getWizardData()` function, after fetching storages (inside the try block where storages/bridges/nextVmid are fetched in parallel):

- Find storages that support `vztmpl` content (filter `storageList` where `s.content?.includes("vztmpl")`).
- For each vztmpl-capable storage, call `templates.listDownloadedTemplates(client, nodeName, storageName)`.
- Import `templates` from `@/lib/proxmox` (already imported in the file via `import { ... templates ... } from "@/lib/proxmox"` — but check: it's currently NOT imported. Add it to the existing import: `import { ..., templates as proxmoxTemplates } from "@/lib/proxmox"`).
- Flatten results and map to `WizardOsTemplate[]`. Extract human-readable name from volid by stripping the `storage:vztmpl/` prefix and the file extension (`.tar.zst`, `.tar.gz`, `.tar.xz`).
- Add `osTemplates` to all return paths (empty array `[]` for error/fallback paths).

**5. Make `ostemplate` required in the base schema** in `apps/dashboard/src/lib/containers/schemas.ts`:

Change `ostemplate: z.string().optional()` to `ostemplate: z.string().min(1, "OS template is required")` in `containerConfigBaseSchema`. This ensures the user MUST select an OS template.

Leave `createContainerInputSchema`'s `ostemplate` field as `z.string().optional()` — the server action can still handle the field being absent for backward compat, but in practice the form will always send it now.

**6. Remove the hardcoded fallback** in `createContainerAction` in `actions.ts`:

Replace the fallback logic (lines ~387-401):

```ts
let ostemplate = data.ostemplate || "";
if (!ostemplate && data.templateId) {
  const template = await prisma.template.findUnique(...);
  if (template?.osTemplate) {
    ostemplate = `local:vztmpl/${template.osTemplate}_amd64.tar.zst`;
  }
}
if (!ostemplate) {
  ostemplate = "local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst";
}
```

With simpler logic:

```ts
const ostemplate = data.ostemplate || "";
if (!ostemplate) {
  throw new Error(
    "OS template is required. Please select an OS template in the Configure step.",
  );
}
```

The template lookup fallback can stay as a secondary attempt, but the hardcoded `debian-12-standard` path MUST be removed. The user-selected value from the form is the source of truth.
</action>
<verify>
Run `npx tsc --noEmit` from `apps/dashboard` to verify no type errors.
Verify the new `listDownloadedTemplates` function exists in templates.ts.
Verify `WizardData` includes `osTemplates` field.
Verify the hardcoded fallback template path is removed from `createContainerAction`.
</verify>
<done>
`getWizardData()` fetches downloaded OS templates from Proxmox storage and includes them in `WizardData.osTemplates`. The `containerConfigBaseSchema` requires `ostemplate` selection. The hardcoded Debian fallback in `createContainerAction` is removed.
</done>
</task>

<task type="auto">
  <name>Task 2: Add OS template dropdown to Configure step and wire through wizard</name>
  <files>
    apps/dashboard/src/app/(dashboard)/containers/new/page.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/container-wizard.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/configure-step.tsx
    apps/dashboard/src/app/(dashboard)/containers/new/steps/review-step.tsx
  </files>
  <action>
**1. Thread `osTemplates` from page → wizard → configure-step:**

In `page.tsx`, destructure `osTemplates` from `getWizardData()` and pass it to `<ContainerWizard>`:

```tsx
const { templates, storages, bridges, nextVmid, noNodeConfigured, osTemplates } = await getWizardData();
// ...
<ContainerWizard ... osTemplates={osTemplates} />
```

In `container-wizard.tsx`:

- Add `osTemplates` to `ContainerWizardProps` interface (type: `WizardOsTemplate[]` — import from actions).
- Pass `osTemplates` to `<ConfigureStep>`.

**2. Add OS template Select dropdown to `configure-step.tsx`:**

- Add `osTemplates` to `ConfigureStepProps` with type from actions: `Array<{ volid: string; name: string; size: number }>`.
- Add an **"OS Template" section** at the TOP of the form, right after the form opening and BEFORE the Identity section. This is the most important field — it should be prominent.
- Use the section heading pattern matching the existing sections:

  ```tsx
  <div className="space-y-4">
    <h3 className="text-sm font-medium text-muted-foreground uppercase tracking-wider">
      OS Template
    </h3>
    <FormField
      control={form.control}
      name="ostemplate"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Template</FormLabel>
          {osTemplates.length > 0 ? (
            <Select onValueChange={field.onChange} defaultValue={field.value}>
              <FormControl>
                <SelectTrigger>
                  <SelectValue placeholder="Select an OS template" />
                </SelectTrigger>
              </FormControl>
              <SelectContent>
                {osTemplates.map((t) => (
                  <SelectItem key={t.volid} value={t.volid}>
                    {t.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          ) : (
            <FormControl>
              <Input placeholder="local:vztmpl/debian-12-standard_12.7-1_amd64.tar.zst" {...field} />
            </FormControl>
          )}
          <FormDescription>
            The OS template to use for the container. Only downloaded templates are shown.
          </FormDescription>
          <FormMessage />
        </FormItem>
      )}
    />
  </div>
  <Separator />
  ```

- The default value for `ostemplate` in the form's `defaultValues` should be: `data?.ostemplate ?? defaultsFromTemplate?.osTemplate ?? osTemplates[0]?.volid ?? ""`. This auto-selects the first available template if none was previously selected.

- In the `useEffect` for template defaults, also set ostemplate: `if (defaultsFromTemplate.osTemplate) form.setValue("ostemplate", defaultsFromTemplate.osTemplate)`.

**3. Show OS template in the Review step (`review-step.tsx`):**

- Add `osTemplateName?: string` to `ReviewStepProps` (pass from container-wizard).
- In the "Template" Card section, add a `<ReviewItem>` showing the OS template:

  ```tsx
  <ReviewItem label="OS Template" value={config.ostemplate || "Not set"} />
  ```

  Add this below the existing template name display.

- In `container-wizard.tsx`, pass `osTemplateName` to ReviewStep. Can just pass `configData?.ostemplate` directly since the volid is descriptive enough, or extract the name portion.

**4. Verify the data flow is complete:**

- `getWizardData()` → `page.tsx` → `ContainerWizard` → `ConfigureStep` (osTemplates prop)
- User selects template → stored in form's `ostemplate` field → `onNext(values)` → `configData.ostemplate`
- `handleDeploy()` already passes `ostemplate: configData.ostemplate` to `createContainerAction`
- `createContainerAction` uses `data.ostemplate` for the worker job

All shadcn/ui components must be used (Select, FormField, FormItem, FormLabel, FormControl, FormMessage, FormDescription). No custom HTML select elements.
</action>
<verify>
Run `npx tsc --noEmit` from `apps/dashboard` to verify no type errors.
Run `npm run build` from `apps/dashboard` (or workspace root) to verify the build succeeds.
Visually confirm by checking the component renders a Select dropdown for OS template when osTemplates array is non-empty.
</verify>
<done>
The Configure step shows an OS template dropdown populated with templates downloaded on Proxmox storage. The selected template volid flows through the wizard to `createContainerAction` and into the BullMQ job config. The Review step displays the selected OS template. The hardcoded fallback is gone — user must select a real template.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npm run build` succeeds
3. Navigate to `/containers/new` → Step 2 (Configure) → "OS Template" section is visible at the top with a dropdown
4. Dropdown shows templates from Proxmox storage (e.g., `debian-12-standard_12.7-1_amd64`)
5. Selecting a template and completing the wizard → Review step shows the OS template
6. Deploying uses the selected template volid instead of a hardcoded path
7. If no osTemplates available, falls back to a text input for manual entry
</verification>

<success_criteria>

- OS template dropdown appears in Configure step with downloaded templates from Proxmox storage
- Selected ostemplate flows through wizard → createContainerAction → worker job
- No hardcoded fallback template path exists in the codebase
- Build and type checking pass
- UAT test #15 gap is resolved (container creation succeeds with a real template)
  </success_criteria>

<output>
After completion, create `.planning/phases/03-container-creation/03-05-SUMMARY.md`
</output>
