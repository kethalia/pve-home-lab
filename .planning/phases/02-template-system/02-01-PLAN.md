---
phase: 02-template-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/src/lib/templates/discovery.ts
  - apps/dashboard/src/lib/templates/parser.ts
  - apps/dashboard/src/lib/templates/actions.ts
autonomous: true

must_haves:
  truths:
    - "Running discovery scans infra/lxc/templates/ and finds the web3-dev template"
    - "template.conf is parsed into structured data (name, tags, CPU, RAM, disk, features)"
    - "All 11 scripts are discovered with correct numeric order and full content"
    - "Package files (base.apt, development.apt) are parsed into named buckets with individual packages"
    - "Config files with .path and .policy sidecars are discovered with target path, policy, and content"
    - "Re-running discovery does not create duplicate records (idempotent upsert)"
  artifacts:
    - path: "apps/dashboard/src/lib/templates/parser.ts"
      provides: "Functions to parse template.conf, scripts, packages, and files from filesystem"
      contains: "parseTemplateConf"
    - path: "apps/dashboard/src/lib/templates/discovery.ts"
      provides: "discoverTemplates() that scans filesystem and upserts to database"
      contains: "discoverTemplates"
    - path: "apps/dashboard/src/lib/templates/actions.ts"
      provides: "Server action to trigger template discovery"
      contains: "use server"
  key_links:
    - from: "apps/dashboard/src/lib/templates/discovery.ts"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Uses Prisma to upsert Template, TemplateScript, TemplateFile, Package, PackageBucket"
      pattern: "prisma\\.(template|templateScript|templateFile|package|packageBucket)"
    - from: "apps/dashboard/src/lib/templates/discovery.ts"
      to: "apps/dashboard/src/lib/templates/parser.ts"
      via: "Imports parsing functions for template.conf, scripts, packages, files"
      pattern: "import.*from.*parser"
    - from: "apps/dashboard/src/lib/templates/actions.ts"
      to: "apps/dashboard/src/lib/templates/discovery.ts"
      via: "Server action calls discoverTemplates()"
      pattern: "discoverTemplates"
---

<objective>
Build the template discovery engine that scans infra/lxc/templates/ directories, parses template configuration files (template.conf, scripts, packages, config files with sidecars), and upserts everything into the database via Prisma.

Purpose: The discovery engine is the foundation for the entire template system — all browsing, editing, and container creation starts with discovered templates. This plan focuses purely on the backend parsing and database sync.

Output: A `discoverTemplates()` function and a server action that triggers it, capable of idempotently syncing filesystem templates into the database.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

@apps/dashboard/prisma/schema.prisma
@apps/dashboard/src/lib/db.ts
@infra/lxc/templates/web3-dev/template.conf
@infra/lxc/templates/web3-dev/container-configs/packages/base.apt
@infra/lxc/templates/web3-dev/container-configs/packages/development.apt
@infra/lxc/templates/web3-dev/container-configs/files/bashrc.path
@infra/lxc/templates/web3-dev/container-configs/files/bashrc.policy
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template filesystem parser</name>
  <files>
    apps/dashboard/src/lib/templates/parser.ts
  </files>
  <action>
Create `src/lib/templates/parser.ts` with pure functions for parsing each template component. This file has NO database dependencies — it only reads the filesystem and returns typed data.

Add `import "server-only"` at top (filesystem access is server-side only).

1. **Type definitions** at the top of the file:

   ```ts
   interface ParsedTemplate {
     name: string; // directory name, e.g., "web3-dev"
     appName: string; // TEMPLATE_APP value
     description: string; // TEMPLATE_DESCRIPTION value
     tags: string[]; // TEMPLATE_TAGS split by ";"
     cores: number; // TEMPLATE_CPU
     memory: number; // TEMPLATE_RAM in MB
     diskSize: number; // TEMPLATE_DISK in GB
     osTemplate: string; // "${TEMPLATE_OS}-${TEMPLATE_VERSION}-standard"
     unprivileged: boolean; // TEMPLATE_UNPRIVILEGED === "1"
     nesting: boolean; // TEMPLATE_NESTING === "1"
     keyctl: boolean; // TEMPLATE_KEYCTL === "1"
     fuse: boolean; // TEMPLATE_FUSE === "1"
     path: string; // absolute path to template directory
   }

   interface ParsedScript {
     name: string; // filename without numeric prefix, e.g., "pre-checks.sh"
     fullName: string; // full filename, e.g., "00-pre-checks.sh"
     order: number; // numeric prefix, e.g., 0, 1, 2...
     content: string; // full file content
   }

   interface ParsedPackageBucket {
     name: string; // filename without extension, e.g., "base", "development"
     manager: "apt" | "npm" | "pip"; // determined by file extension
     packages: string[]; // individual package names (comments/blanks stripped)
   }

   interface ParsedFile {
     name: string; // filename, e.g., "bashrc"
     targetPath: string; // from .path sidecar, e.g., "/home/coder"
     policy: string; // from .policy sidecar, e.g., "default"
     content: string; // file content
   }
   ```

2. **`parseTemplateConf(confPath: string): Promise<ParsedTemplate>`**
   - Read template.conf using `fs.readFile`
   - Parse bash-style variable assignments. For each line matching `^(\w+)=(.*)$`:
     - Strip quotes (single and double) from value
     - Handle `${VAR:-default}` patterns by extracting the default value
     - Build a key-value map
   - Map TEMPLATE\_\* vars to ParsedTemplate fields
   - The `name` field comes from the parent directory name (use `path.basename(path.dirname(confPath))`)
   - Construct `osTemplate` as `"${os}-${version}-standard"` from TEMPLATE_OS and TEMPLATE_VERSION

3. **`parseScripts(scriptsDir: string): Promise<ParsedScript[]>`**
   - Read all \*.sh files in the directory (exclude .gitkeep, README.md)
   - For each .sh file, extract numeric prefix: match `^(\d+)-(.*)$` on filename
   - Sort by numeric prefix ascending
   - Read full content of each file
   - Return sorted array

4. **`parsePackages(packagesDir: string): Promise<ParsedPackageBucket[]>`**
   - Read all _.apt, _.npm, \*.pip files (exclude .gitkeep, README.md)
   - Determine manager from extension: .apt → "apt", .npm → "npm", .pip → "pip"
   - Bucket name = filename without extension (e.g., "base" from "base.apt")
   - Parse content: split by newlines, trim each line, filter out empty lines and lines starting with "#"
   - Return array of buckets

5. **`parseFiles(filesDir: string): Promise<ParsedFile[]>`**
   - List all files in directory, excluding .gitkeep, README.md, and any file ending in .path or .policy
   - For each remaining file (the actual config file):
     - Read the file content
     - Read `{filename}.path` sidecar — trim whitespace, this is the targetPath
     - Read `{filename}.policy` sidecar — trim whitespace, this is the policy
     - If .path or .policy sidecar is missing, skip this file (log warning to console)
   - Return array of ParsedFile

6. **`discoverTemplateDirs(rootDir: string): Promise<string[]>`**
   - Read rootDir, return full paths to subdirectories that contain a `template.conf` file
   - Use `fs.readdir` with `withFileTypes: true`, filter for directories, check if template.conf exists in each

7. **`parseFullTemplate(templateDir: string): Promise<{ template: ParsedTemplate; scripts: ParsedScript[]; packages: ParsedPackageBucket[]; files: ParsedFile[] }>`**
   - Orchestrator that calls all parsers for a single template directory
   - Paths: `${templateDir}/template.conf`, `${templateDir}/container-configs/scripts/`, `${templateDir}/container-configs/packages/`, `${templateDir}/container-configs/files/`
   - Handle missing subdirectories gracefully (return empty arrays)

Export all types and functions. Use Node.js `fs/promises` and `path` modules.
</action>
<verify> - `npx tsc --noEmit` passes in apps/dashboard - File exists at apps/dashboard/src/lib/templates/parser.ts - Module exports: parseTemplateConf, parseScripts, parsePackages, parseFiles, discoverTemplateDirs, parseFullTemplate - All types exported: ParsedTemplate, ParsedScript, ParsedPackageBucket, ParsedFile
</verify>
<done> - Parser module reads template.conf and extracts all TEMPLATE\_\* variables including defaults from ${VAR:-default} syntax - Scripts parser orders by numeric prefix and reads full content - Packages parser groups by file (bucket name) and strips comments/blanks - Files parser reads content + .path/.policy sidecars - All functions are pure (no DB access) and return typed data
</done>
</task>

<task type="auto">
  <name>Task 2: Discovery engine and server action</name>
  <files>
    apps/dashboard/src/lib/templates/discovery.ts
    apps/dashboard/src/lib/templates/actions.ts
  </files>
  <action>
1. Create `src/lib/templates/discovery.ts` with the database sync logic.

Add `import "server-only"` at top.

Import parser functions from `./parser` and Prisma types from `@/generated/prisma/client`.

Access Prisma directly (not through DatabaseService for now — we'll add DatabaseService methods in Plan 02). Use the same prismaInstance pattern from `@/lib/db.ts`:

```ts
import { PrismaClient } from "@/generated/prisma/client";
import { PrismaPg } from "@prisma/adapter-pg";
import { Pool } from "pg";
```

Actually, simpler: import the prisma instance. Looking at db.ts, the prismaInstance is not exported directly. The cleanest approach: add a `static get db()` getter to DatabaseService that returns the prisma instance, OR export prismaInstance. Use the approach of exporting `prismaInstance` as `prisma` from db.ts (add `export { prismaInstance as prisma }`). This keeps things simple while allowing direct Prisma access for complex operations like discovery.

**`discoverTemplates(rootDir?: string): Promise<DiscoveryResult>`**:

- Default rootDir: `path.resolve(process.cwd(), "../../infra/lxc/templates")` — this resolves relative to the dashboard app's working directory to the monorepo root's infra directory. Alternatively, use `process.env.TEMPLATES_ROOT` if set.
- Call `discoverTemplateDirs(rootDir)` to get template directories
- For each template directory, call `parseFullTemplate(dir)`
- For each parsed template, run a Prisma transaction (`prisma.$transaction`) to upsert:

  a. **Upsert Template**: Use `prisma.template.upsert()` with:
  - `where: { name: parsed.template.name }`
  - `create`: all fields from ParsedTemplate, source: "filesystem", tags as semicolon-joined string
  - `update`: same fields (re-syncs on re-run)

  b. **Sync Scripts**: Delete existing scripts for this template (`prisma.templateScript.deleteMany({ where: { templateId } })`), then create all from parsed data. This ensures clean sync — no orphans from renamed/removed scripts.

  c. **Sync Files**: Same pattern — delete existing, create all from parsed files. Map policy string to FilePolicy enum.

  d. **Sync Packages**: For each ParsedPackageBucket:
  - Upsert PackageBucket by name (`prisma.packageBucket.upsert`)
  - Delete existing packages for this bucket (`prisma.package.deleteMany({ where: { bucketId } })`)
  - Create packages with `manager` from bucket's manager field
  - Also create direct template-package associations: for each package in the bucket, also create a Package record with `templateId` set (linking template to its packages directly)

  Actually, re-examining the schema: Package has BOTH `bucketId` and `templateId` as optional fields. The intent seems to be:
  - Packages in a bucket: `bucketId` set, `templateId` null
  - Packages directly on a template: `bucketId` null, `templateId` set

  For discovery: Create packages in their buckets (bucketId set). The template-to-packages link should go through the bucket. We do NOT duplicate packages with templateId — that's for custom packages added directly to templates in the editor.

  So the flow is:
  - Upsert PackageBucket by name
  - Delete existing packages in that bucket
  - Create packages with bucketId set, templateId null

- Return a result object:
  ```ts
  interface DiscoveryResult {
    discovered: number;
    templates: {
      name: string;
      scripts: number;
      packages: number;
      files: number;
    }[];
    errors: { template: string; error: string }[];
  }
  ```

2. **Add prisma export to db.ts**: Add `export { prismaInstance as prisma }` to `src/lib/db.ts` so discovery.ts can import it directly for complex transaction operations.

3. Create `src/lib/templates/actions.ts` with `"use server"` directive:

   **`discoverTemplatesAction(): Promise<DiscoveryResult>`**:
   - Calls `discoverTemplates()` from `./discovery`
   - Wraps in try/catch, returns error result on failure
   - This is the server action that UI buttons will call

   **`getDiscoveryStatus(): Promise<{ templateCount: number; lastDiscovery: string | null }>`**:
   - Quick query: count templates where source = "filesystem"
   - Returns count and most recent updatedAt timestamp
   - Useful for UI to show "Last synced: ..." info

Export the DiscoveryResult type from discovery.ts.
</action>
<verify> - `npx tsc --noEmit` passes in apps/dashboard - Files exist: discovery.ts, actions.ts - discovery.ts exports discoverTemplates and DiscoveryResult - actions.ts has "use server" directive and exports discoverTemplatesAction - db.ts now exports prisma instance - To test actual discovery (requires running DB): Start dev environment with `docker compose -f docker-compose.dev.yaml up -d`, run `npx prisma db push`, then test by importing and calling discoverTemplates() in a script or via the Next.js dev server
</verify>
<done> - Discovery engine scans infra/lxc/templates/ and finds template directories with template.conf - Each template is fully parsed and upserted (Template, TemplateScript, TemplateFile, PackageBucket, Package) - Re-running does not create duplicates (upsert for templates/buckets, delete+recreate for scripts/files/packages) - Server action available for UI to trigger discovery - prisma instance exported from db.ts for direct access in complex operations
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — all types correct
2. Parser functions handle the web3-dev template structure:
   - template.conf with ${VAR:-default} syntax
   - 11 scripts with numeric prefixes (00 through 99)
   - 2 package files (base.apt, development.apt)
   - Config files with .path and .policy sidecars (bashrc, aliases.sh, gitconfig, config-manager-status.sh)
3. Discovery upserts are idempotent — running twice produces same DB state
4. Server action is callable from client components
</verification>

<success_criteria>

- Parser correctly extracts all template.conf variables including bash default syntax
- All 11 scripts discovered in numeric order with full content
- Package files parsed into named buckets (base, development) with correct packages
- Config files paired with their .path and .policy sidecars
- Database sync is transactional and idempotent
- Server action triggers full discovery cycle
  </success_criteria>

<output>
After completion, create `.planning/phases/02-template-system/02-01-SUMMARY.md`
</output>
