---
phase: 02-template-system
plan: 05
type: execute
wave: 4
depends_on: ["02-02", "02-03"]
files_modified:
  - apps/dashboard/src/lib/templates/actions.ts
  - apps/dashboard/src/app/templates/new/page.tsx
  - apps/dashboard/src/app/templates/[id]/edit/page.tsx
  - apps/dashboard/src/components/templates/template-form.tsx
  - apps/dashboard/src/components/templates/script-editor.tsx
  - apps/dashboard/src/components/templates/file-editor.tsx
autonomous: true

must_haves:
  truths:
    - "User can visit /templates/new and see a multi-section form for creating a template"
    - "User can fill in basics (name, description, tags), resources (CPU, RAM, disk), and features (nesting, keyctl, fuse)"
    - "User can add scripts with name, order, and content"
    - "User can reorder scripts via order number input"
    - "User can select package buckets to associate with the template"
    - "User can add config files with name, target path, policy, and content"
    - "Submitting the form creates a template with all associated data"
    - "User can visit /templates/[id]/edit and see the same form pre-populated with existing data"
    - "Saving edits updates the template and all associated data"
    - "Form validation prevents submission with missing required fields"
  artifacts:
    - path: "apps/dashboard/src/components/templates/template-form.tsx"
      provides: "Shared form component for create and edit modes"
      contains: "TemplateForm"
    - path: "apps/dashboard/src/lib/templates/actions.ts"
      provides: "createTemplateAction and updateTemplateAction server actions"
      contains: "createTemplateAction"
    - path: "apps/dashboard/src/app/templates/new/page.tsx"
      provides: "Template creation page"
      min_lines: 15
    - path: "apps/dashboard/src/app/templates/[id]/edit/page.tsx"
      provides: "Template edit page pre-populated with data"
      min_lines: 20
  key_links:
    - from: "apps/dashboard/src/components/templates/template-form.tsx"
      to: "apps/dashboard/src/lib/templates/actions.ts"
      via: "Form submits via createTemplateAction or updateTemplateAction"
      pattern: "createTemplateAction|updateTemplateAction"
    - from: "apps/dashboard/src/app/templates/[id]/edit/page.tsx"
      to: "apps/dashboard/src/lib/db.ts"
      via: "RSC loads template via DatabaseService.getTemplateById()"
      pattern: "DatabaseService\\.getTemplateById"
    - from: "apps/dashboard/src/components/templates/template-form.tsx"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Loads buckets for package selection via DatabaseService.listBuckets()"
      pattern: "listBuckets|buckets"
---

<objective>
Build the template creator (/templates/new) and editor (/templates/[id]/edit) with a shared multi-section form supporting basics, resources, features, scripts, packages, and files.

Purpose: Users need to create custom templates and edit existing ones. This is the write-side of the template system — complementing the read-only browser and detail views.

Output: Working create and edit forms that save complete templates with scripts, packages, and files to the database.
</objective>

<execution_context>
@/home/coder/.config/Claude/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-template-system/02-02-SUMMARY.md
@.planning/phases/02-template-system/02-03-SUMMARY.md

@apps/dashboard/src/lib/db.ts
@apps/dashboard/src/lib/templates/actions.ts
@apps/dashboard/prisma/schema.prisma
@apps/dashboard/src/components/ui/card.tsx
@apps/dashboard/src/components/ui/input.tsx
@apps/dashboard/src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template create/update server actions</name>
  <files>
    apps/dashboard/src/lib/templates/actions.ts
    apps/dashboard/src/lib/db.ts
  </files>
  <action>
Extend the existing `src/lib/templates/actions.ts` (from Plan 01) and `src/lib/db.ts` with template creation and update capabilities.

1. **Add to DatabaseService in `src/lib/db.ts`:**

   a. **`createTemplate(data: CreateTemplateInput): Promise<Template>`**
   - Input type:
     ```ts
     interface CreateTemplateInput {
       name: string;
       description?: string;
       osTemplate?: string;
       cores?: number;
       memory?: number;
       swap?: number;
       diskSize?: number;
       storage?: string;
       bridge?: string;
       unprivileged?: boolean;
       nesting?: boolean;
       keyctl?: boolean;
       fuse?: boolean;
       tags?: string;
       scripts?: {
         name: string;
         order: number;
         content: string;
         description?: string;
         enabled?: boolean;
       }[];
       files?: {
         name: string;
         targetPath: string;
         policy: FilePolicy;
         content: string;
       }[];
       packageIds?: string[]; // IDs of packages to link directly to template
     }
     ```
   - Use `prisma.$transaction` to create template + related records atomically:
     - Create Template with base fields, source: "custom"
     - Create TemplateScript records if scripts provided
     - Create TemplateFile records if files provided
     - For packageIds: create Package records with templateId (or use connect if linking existing)
   - Export CreateTemplateInput type

   b. **`updateTemplate(id: string, data: UpdateTemplateInput): Promise<Template>`**
   - Similar to create but uses upsert/replace strategy:
     - Update Template base fields
     - Delete existing scripts, create new ones (full replace — simplest for reordering)
     - Delete existing files, create new ones
     - Delete existing direct packages (templateId = this id), create new ones
   - Wrap in `prisma.$transaction`
   - Export UpdateTemplateInput type (same as CreateTemplateInput but all fields optional)

2. **Add to `src/lib/templates/actions.ts`:**

   a. **`createTemplateAction(prevState: ActionState, formData: FormData): Promise<ActionState>`** - Parse formData. The form will submit structured data as JSON in a hidden field for complex nested data (scripts, files). Strategy: - Basic fields: extract directly from formData (name, description, cores, memory, etc.) - Complex fields: formData contains a `scripts` field with JSON string, `files` field with JSON string, `packageIds` field with comma-separated IDs - Validate with Zod: - name: string, 1-100 chars, required - description: string, optional, max 500 chars - cores: number, 1-64, optional - memory: number, 128-131072, optional (MB) - swap: number, 0-131072, optional (MB) - diskSize: number, 1-10000, optional (GB) - scripts: array of { name, order, content } objects, optional - files: array of { name, targetPath, policy, content } objects, optional - On success: `revalidatePath("/templates")`, `redirect("/templates/${template.id}")` - On error: return `{ success: false, error: validation or DB error message }`

   b. **`updateTemplateAction(prevState: ActionState, formData: FormData): Promise<ActionState>`** - Extract id from formData (hidden field) - Same parsing and validation as create - Call DatabaseService.updateTemplate(id, data) - On success: `revalidatePath("/templates")`, `revalidatePath("/templates/${id}")`, `redirect("/templates/${id}")` - On error: return error state

   Both actions use the same Zod schema. Define it once as `templateFormSchema` and reuse.
   </action>
   <verify> - `npx tsc --noEmit` passes - DatabaseService has createTemplate and updateTemplate methods - actions.ts has createTemplateAction and updateTemplateAction - Zod validation schema covers all template fields
   </verify>
   <done> - Template creation saves template + scripts + files + packages atomically - Template update replaces all associated data in a transaction - Server actions validate all input with Zod - Successful create/update redirects to template detail page - Error states return user-friendly messages
   </done>
   </task>

<task type="auto">
  <name>Task 2: Script editor and file editor sub-components</name>
  <files>
    apps/dashboard/src/components/templates/script-editor.tsx
    apps/dashboard/src/components/templates/file-editor.tsx
  </files>
  <action>
Install additional shadcn components if not already present:
```bash
cd apps/dashboard && npx shadcn@latest add switch select checkbox --yes
```

1. **Create `src/components/templates/script-editor.tsx`** ("use client"):
   - A sub-form for managing template scripts
   - Props: `{ scripts: ScriptInput[]; onChange: (scripts: ScriptInput[]) => void }` where `ScriptInput = { name: string; order: number; content: string; description?: string; enabled: boolean }`
   - UI:
     - List of script entries, each with:
       - Order number input (number type, small width)
       - Name input
       - Description input (optional, smaller)
       - Content textarea (monospace, resizable, min 4 rows)
       - Enabled toggle (Switch component)
       - Remove button (X icon)
     - "Add Script" button at bottom — adds empty entry with next order number
     - Scripts auto-sort by order number in display
   - State is managed by parent (controlled component via onChange)

2. **Create `src/components/templates/file-editor.tsx`** ("use client"):
   - A sub-form for managing template config files
   - Props: `{ files: FileInput[]; onChange: (files: FileInput[]) => void }` where `FileInput = { name: string; targetPath: string; policy: "replace" | "default" | "backup"; content: string }`
   - UI:
     - List of file entries, each with:
       - Name input
       - Target path input (monospace, e.g., "/home/coder/.config")
       - Policy select (replace, default, backup)
       - Content textarea (monospace, resizable, min 4 rows)
       - Remove button
     - "Add File" button at bottom
   - Controlled component via onChange
     </action>
     <verify>
   - `npx tsc --noEmit` passes
   - ScriptEditor component renders with add/remove/reorder functionality
   - FileEditor component renders with add/remove functionality
   - Both are controlled components (receive state, emit onChange)
     </verify>
     <done>
   - Script editor supports add, remove, reorder by number, content editing, and enable toggle
   - File editor supports add, remove with name, target path, policy select, and content editing
   - Both components are reusable controlled sub-forms ready for the template form
     </done>
     </task>

<task type="auto">
  <name>Task 3: Template form component and create/edit pages</name>
  <files>
    apps/dashboard/src/components/templates/template-form.tsx
    apps/dashboard/src/app/templates/new/page.tsx
    apps/dashboard/src/app/templates/[id]/edit/page.tsx
  </files>
  <action>
1. **Create `src/components/templates/template-form.tsx`** ("use client"):
   - Props: `{ mode: "create" | "edit"; template?: TemplateWithDetails; buckets: BucketWithPackages[]; action: (prevState: ActionState, formData: FormData) => Promise<ActionState> }`
   - This is the main form component used by both /new and /edit pages
   - Use `useActionState(action, { success: false })` for form submission
   - Local state for complex fields (scripts, files, selectedPackageIds) managed with useState
   - On form submit, serialize complex state into hidden fields as JSON strings

**Form sections (each in a Card):**

**Section 1: Basics**

- Name (Input, required)
- Description (Textarea, optional)
- Tags (Input, comma-separated, optional)
- OS Template (Input, e.g., "debian-12-standard", optional)

**Section 2: Resources**

- CPU Cores (Input type="number", placeholder="4")
- Memory MB (Input type="number", placeholder="8192")
- Swap MB (Input type="number", placeholder="0")
- Disk Size GB (Input type="number", placeholder="20")
- Storage (Input, placeholder="local-lvm")
- Bridge (Input, placeholder="vmbr0")
- Layout: 2-3 column grid for resource fields

**Section 3: Features**

- Unprivileged (Switch, default true)
- Nesting (Switch, default false)
- Keyctl (Switch, default false)
- FUSE (Switch, default false)
- Layout: horizontal row of switch + label pairs

**Section 4: Scripts**

- `<ScriptEditor scripts={scripts} onChange={setScripts} />`

**Section 5: Packages**

- Checkbox list of available buckets (from props.buckets)
- Each bucket shows: name, description, package count
- Selected buckets are tracked in state
- Packages from selected buckets are shown as a preview (read-only badge list)
- Hidden field serializes selected bucket IDs

**Section 6: Files**

- `<FileEditor files={files} onChange={setFiles} />`

**Form footer:**

- Cancel button (link back to /templates)
- Submit button with loading state ("Creating..." / "Saving...")
- Error display if action returns error

**Hidden fields for serialization:**

- `<input type="hidden" name="scripts" value={JSON.stringify(scripts)} />`
- `<input type="hidden" name="files" value={JSON.stringify(files)} />`
- `<input type="hidden" name="packageIds" value={selectedPackageIds.join(",")} />`
- `<input type="hidden" name="id" value={template?.id} />` (edit mode only)

**Pre-population (edit mode):**

- When `template` prop is provided, initialize all state from template data
- Scripts: map from template.scripts
- Files: map from template.files
- Packages: determine which buckets are selected based on template.packages

2. **Create `src/app/templates/new/page.tsx`** (Server Component):
   - Fetch buckets: `DatabaseService.listBuckets()`
   - Render: header "Create Template", `<TemplateForm mode="create" buckets={buckets} action={createTemplateAction} />`
   - Import createTemplateAction from actions

3. **Create `src/app/templates/[id]/edit/page.tsx`** (Server Component):
   - Accept `params` prop, await to get id
   - Fetch template: `DatabaseService.getTemplateById(id)` — notFound() if missing
   - Fetch buckets: `DatabaseService.listBuckets()`
   - Render: header "Edit Template: {name}", `<TemplateForm mode="edit" template={template} buckets={buckets} action={updateTemplateAction} />`
   - Import updateTemplateAction from actions
     </action>
     <verify>
   - `npx tsc --noEmit` passes
   - /templates/new page renders with empty form
   - All 6 form sections visible: basics, resources, features, scripts, packages, files
   - Can add/remove scripts in the script editor
   - Can add/remove files in the file editor
   - Can select/deselect package buckets
   - Form validation prevents empty name submission
   - /templates/[id]/edit page renders with pre-populated form
   - Submit creates/updates template and redirects to detail page
     </verify>
     <done>
   - /templates/new renders complete multi-section form
   - All template fields editable: basics, resources, features, scripts, packages, files
   - Form submission creates template atomically via server action
   - /templates/[id]/edit pre-populates all fields from existing template
   - Form validation works for required fields
   - Success redirects to template detail page
     </done>
     </task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all types correct
2. /templates/new renders full form with all sections
3. Create flow: fill form → submit → redirected to /templates/[id] with correct data
4. /templates/[id]/edit renders pre-populated form
5. Edit flow: modify fields → submit → detail page shows changes
6. Scripts: add, reorder, remove, content editing all work
7. Files: add, remove, path/policy/content editing all work
8. Package bucket selection reflects available buckets
9. Form validation catches missing required fields
</verification>

<success_criteria>

- Complete template creation flow from empty form to saved template
- Complete template edit flow from pre-populated form to updated template
- Scripts editor supports add, remove, reorder, and content editing
- File editor supports add, remove with path, policy, and content
- Package bucket selection works with preview
- Validation prevents invalid submissions
- Both create and edit share the same form component
  </success_criteria>

<output>
After completion, create `.planning/phases/02-template-system/02-05-SUMMARY.md`
</output>
