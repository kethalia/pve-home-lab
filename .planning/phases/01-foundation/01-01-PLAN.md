---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/dashboard/src/lib/session.ts
  - apps/dashboard/src/lib/auth/actions.ts
  - apps/dashboard/src/app/login/page.tsx
  - apps/dashboard/package.json
autonomous: true

must_haves:
  truths:
    - "User can visit /login and see a form with username, realm dropdown, and password fields"
    - "User can submit valid Proxmox credentials and get redirected to /"
    - "User sees an error message when credentials are invalid or PVE is unreachable"
    - "Session is stored in Redis with ticket, CSRF token, username, and expiry"
    - "Logout clears both the Redis session and the browser cookie"
  artifacts:
    - path: "apps/dashboard/src/lib/session.ts"
      provides: "Session config, getSession/createSession/destroySession helpers using iron-session + Redis"
      contains: "getIronSession"
    - path: "apps/dashboard/src/lib/auth/actions.ts"
      provides: "loginAction and logoutAction server actions"
      contains: "use server"
    - path: "apps/dashboard/src/app/login/page.tsx"
      provides: "Login page with form UI"
      min_lines: 50
  key_links:
    - from: "apps/dashboard/src/lib/auth/actions.ts"
      to: "apps/dashboard/src/lib/proxmox/auth.ts"
      via: "imports login() function"
      pattern: "import.*login.*from.*proxmox/auth"
    - from: "apps/dashboard/src/lib/auth/actions.ts"
      to: "apps/dashboard/src/lib/session.ts"
      via: "creates/destroys sessions"
      pattern: "(createSession|destroySession)"
    - from: "apps/dashboard/src/lib/session.ts"
      to: "apps/dashboard/src/lib/redis.ts"
      via: "stores session data in Redis"
      pattern: "getRedis|redis\.(set|get|del)"
    - from: "apps/dashboard/src/app/login/page.tsx"
      to: "apps/dashboard/src/lib/auth/actions.ts"
      via: "form calls loginAction"
      pattern: "loginAction"
---

<objective>
Implement session management and login flow for Proxmox SSO authentication.

Purpose: Users need to authenticate with their Proxmox VE credentials before accessing any dashboard functionality. This plan creates the session infrastructure (iron-session + Redis), server actions for login/logout, and the login page UI.

Output: Working login page that authenticates against Proxmox VE, stores session in Redis, and sets an encrypted cookie via iron-session.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@apps/dashboard/src/lib/proxmox/auth.ts
@apps/dashboard/src/lib/proxmox/types.ts
@apps/dashboard/src/lib/redis.ts
@apps/dashboard/src/lib/encryption.ts
@apps/dashboard/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session infrastructure and auth server actions</name>
  <files>
    apps/dashboard/src/lib/session.ts
    apps/dashboard/src/lib/auth/actions.ts
    apps/dashboard/package.json
  </files>
  <action>
1. Install iron-session: `npm install iron-session` in apps/dashboard.

2. Create `src/lib/session.ts` with:
   - Session data interface: `{ sessionId: string }` — the cookie only stores a session ID, NOT the Proxmox ticket directly. The actual session data lives in Redis.
   - Redis session data interface: `{ ticket: string; csrfToken: string; username: string; realm: string; expiresAt: string }` (ISO date string)
   - iron-session config: cookie name `"lxc-session"`, password from `process.env.SESSION_SECRET` (32+ char secret), cookieOptions: `{ httpOnly: true, sameSite: "strict" as const, secure: process.env.NODE_ENV === "production" }`
   - `getSession(cookies)`: wraps `getIronSession<SessionData>(cookies, sessionOptions)` — use `cookies()` from `next/headers`
   - `getSessionData()`: async function that reads the iron-session cookie, extracts sessionId, fetches `session:{sessionId}` from Redis via `getRedis().get()`, parses JSON, validates not expired, returns typed session data or null
   - `createSession(data: { ticket, csrfToken, username, realm, expiresAt })`: generates crypto.randomUUID() as sessionId, stores JSON in Redis at `session:{sessionId}` with TTL of 2 hours (7200 seconds) via `getRedis().setex()`, sets sessionId in iron-session cookie, saves cookie
   - `destroySession()`: reads iron-session cookie, gets sessionId, deletes `session:{sessionId}` from Redis via `getRedis().del()`, destroys iron-session cookie
   - Export a `getProxmoxCredentials()` helper that calls getSessionData() and returns `ProxmoxTicketCredentials` type or null (for use by API calls later)

3. Create `src/lib/auth/actions.ts` with `"use server"` directive:
   - `loginAction(prevState, formData)`: Server action compatible with useActionState (React 19). Extract username, password, realm from FormData. Validate inputs with Zod (username non-empty string, password non-empty, realm is "pam" | "pve"). Call the existing `login()` from `@/lib/proxmox/auth` using env vars `PROXMOX_HOST` and `PROXMOX_PORT` (default 8006). On success, call `createSession()` with ticket data. Return `{ success: true }`. On error, return `{ success: false, error: "Invalid credentials" }` (don't leak Proxmox error details to client). Use try/catch — catch network errors as "Unable to reach Proxmox server".
   - `logoutAction()`: Server action. Call `destroySession()`. Use `redirect("/login")` from `next/navigation`.

Important: Use `useActionState` pattern (React 19), NOT the deprecated `useFormState`. The loginAction signature should be `(prevState: ActionState, formData: FormData) => Promise<ActionState>` where `ActionState = { success: boolean; error?: string }`.
</action>
<verify> - `npm ls iron-session` confirms installation in apps/dashboard - TypeScript compiles: `npx tsc --noEmit` in apps/dashboard (no type errors) - Session module exports: getSession, getSessionData, createSession, destroySession, getProxmoxCredentials - Auth actions export: loginAction, logoutAction with "use server" directive
</verify>
<done> - iron-session installed and configured with Redis-backed session storage - Session CRUD operations (create, read, delete) working with Redis TTL - loginAction validates input, calls Proxmox login(), creates session on success, returns error on failure - logoutAction destroys session and redirects to /login
</done>
</task>

<task type="auto">
  <name>Task 2: Login page with form UI</name>
  <files>
    apps/dashboard/src/app/login/page.tsx
    apps/dashboard/src/app/login/layout.tsx
  </files>
  <action>
1. Create `src/app/login/layout.tsx`:
   - Simple layout that renders children WITHOUT the sidebar/SidebarProvider. Just a centered container with the app name. This prevents the login page from showing the sidebar navigation.
   - Structure: `<html>` → `<body>` → centered flex container → children
   - NOTE: Since this is a nested layout under app/layout.tsx, it should just return children wrapped in a centering div. The root layout already has html/body. BUT the root layout currently wraps everything in SidebarProvider — this will be fixed in Plan 02 when we update the root layout. For now, create this layout to define the route group.
   - Actually, the cleaner approach: Create `src/app/login/layout.tsx` that just returns `{children}` in a full-screen centered flex container (div only, no html/body). The sidebar from root layout WILL show — Plan 02 fixes this by making the root layout conditional. The login page will still be functional.

2. Create `src/app/login/page.tsx` as a Client Component (`"use client"`):
   - Import `useActionState` from `react` (React 19)
   - Import `useRouter` from `next/navigation`
   - Import `loginAction` from `@/lib/auth/actions`
   - Import shadcn components: Card, CardHeader, CardTitle, CardDescription, CardContent, Button, Input
   - Import `useEffect` from react
   - Use `useActionState(loginAction, { success: false })` for form state
   - On `state.success === true`, use `router.push("/")` in a useEffect
   - Form fields:
     - Username: `<Input name="username" placeholder="admin" required autoFocus />`
     - Realm: `<select name="realm">` with options "pam" (Linux PAM) and "pve" (Proxmox VE). Style with Tailwind classes to match shadcn input styling: `className="flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs transition-colors placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"`. Default selected: "pam".
     - Password: `<Input name="password" type="password" required />`
   - Submit button with loading state: use `useFormStatus` from `react-dom` in a separate SubmitButton component (because useFormStatus must be used inside a form). Show "Signing in..." when pending.
   - Error display: if `state.error`, show it in a red text paragraph above submit button
   - Card layout centered on page: `<div className="flex min-h-screen items-center justify-center">` wrapping a Card with max-w-md
   - Card header: "LXC Manager" title, "Sign in with your Proxmox VE credentials" description
   - Use `<form action={formAction}>` pattern (React 19 server action form)
     </action>
     <verify>
   - `npx tsc --noEmit` passes in apps/dashboard
   - File exists: apps/dashboard/src/app/login/page.tsx
   - Login page renders at http://localhost:3001/login (dev server)
   - Form has 3 fields: username input, realm select, password input
   - Submit button exists with proper text
     </verify>
     <done>
   - Login page renders at /login with username, realm dropdown, and password fields
   - Form submits via React 19 server action pattern (useActionState)
   - Loading state shows "Signing in..." during submission
   - Error messages display when loginAction returns an error
   - Successful login triggers redirect to /
     </done>
     </task>

</tasks>

<verification>
1. `npm install` succeeds and iron-session is in node_modules
2. `npx tsc --noEmit` passes with no type errors
3. Login page is accessible at /login
4. Form fields render correctly (username, realm, password)
5. Session module correctly interfaces with Redis (code review — actual Redis test requires running dev environment)
</verification>

<success_criteria>

- iron-session installed and configured
- Redis-backed session management (create, read, destroy) implemented
- Login and logout server actions complete with Zod validation
- Login page renders with proper form UI using shadcn components
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
